SPEAKER
서영학© 2025 Upstage Co., Ltd.
2저작권안내
(주)업스테이지가 제공하는 모든교육콘텐츠의지식재산권은
운영주체인 (주)업스테이지 또는해당저작물의 적법한 관리자에게 귀속되어 있습니다.
콘텐츠 일부 또는 전부를 복사, 복제, 판매, 재판매 공개, 공유 등을 할수없습니다. 
유출될 경우 지식재산권 침해에 대한 책임을 부담할 수있습니다. 
유출에 해당하여 금지되는 행위의 예시는 다음과 같습니다. 
● 콘텐츠를 재가공하여 온/오프라인으로 공개하는 행위
● 콘텐츠의 일부 또는 전부를 이용하여 인쇄물을 만드는 행위
● 콘텐츠의 전부 또는 일부를 녹취 또는 녹화하거나 녹취록을 작성하는 행위
● 콘텐츠의 전부 또는 일부를 스크린 캡쳐하거나 카메라로 촬영하는 행위
● 지인을 포함한 제3자에게 콘텐츠의 일부 또는 전부를 공유하는 행위
● 다른 정보와 결합하여 Upstage Education의 콘텐츠임을 알아볼 수있는 저작물을 작성, 공개하는 행위
● 제공된 데이터의 일부 혹은전부를 Upstage Education 프로젝트/실습 수행 이외의 목적으로 사용하는 행위위
3오늘의목표: 작업되돌아가기Git 
목차
gitcheckout/switch를통한작업되돌아가기/이동하기
gitbranch를통한작업분리
merge협업과 conflict해결
404 –01
Git Branch 
merge / rebase
Git flow
5만약예전버전을사용해야한다면?Git 
현업에서 다양한 요구사항이 존재, 이전버전에서 작업을시작해야할 수도있다
‘무리한 요구를 하는 클라이언트 ’카카오톡 이모티콘
6만약예전버전을사용해야한다면?Git 
지금라이브 버전에 버그가 있어서 이전버전으로 서비스해야할 거같아요

7만약예전버전을사용해야한다면?Git 
하지만작업중에현실적으로
1. 커밋이 쌓이면 "하던작업을 멈출수가없다"
2. 예전버전과 지금버전사이의 변화등으로 현재작업이 영향이간다 (위험하다)
8git checkoutGit 
특정시점으로 코드를되돌릴때
-Git이저장한시점(commit)으로 이동
-이전커밋시점(snapshot) 이동가능
(잠깐) 다른작업으로 되돌릴 때현재작업이남아있을 때
만약커밋하지 않은파일이 있다면 되돌릴 때문제가 생길수있다

9git stashGit 
깃내부임시저장소
지금하던작업은미완성, commit하기엔너무지저분할때잠시옮겨놓는다
다른작업을해야하는데현재작업중인부분을커밋하기엔애매하고날리기도애매할때쓴다
checkout할때로컬에수정내용이남아있으면섞여서충돌날수있음
내부저장소에코드를잠시보관해남아있는변경이없는깨끗한상태로만들고 checkout하자

Source Tree 에서확인
10(실습) git stash 명령어, 사용법Git 
임시저장 하기
git stash 
메시지지정해서stash 생성
git stash save {메시지}
저장된변경목록보기
git stash list
가장최근저장된stash 보기
git stash show
다시꺼내오기stash 목록에서삭제
git stash pop
꺼내오지만목록에서는삭제하지않음
git stash apply
11git checkout 사용법정리Git 
git checkout
커밋해시로이동가능
git checkout <commit-hash>
브랜치이동
git checkout <브랜치>
새브랜치+ 이동
git checkout -b <브랜치>
파일되돌리기(옛날방식)
git checkout <커밋> --<파일>
12(실습) gitcheckoutGit 
코드를이전버전으로 되돌려보기
1. 두번째커밋hash값확인
2. gitcheckout(커밋hash값앞일부입력)
3. 코드변경과commitlog변경확인
Head 란? 
지금 작업 중인 곳 (현재 위치 )

13(실습) gitcheckoutGit 
코드를이전버전으로 되돌려보기
4. 실제코드로돌아가초기상태로변한코드를확인한다
이 때Detached HEAD 상태 발생
14(심화) Detached HEAD 란? Git 
HEAD는"현재내가보고있는스냅샷" 을가리키는데,
해시로체크아웃하면브랜치가아니라개별커밋을가리키게됩니다.
그래서"Detached HEAD"
→ "브랜치에서떨어져있는상태"
브랜치라는작업흐름내에서이동해야, 수정한내역을잃지않을수있다
이상태에서커밋하면브랜치와연결되지않아서
나중에찾기어려운고아커밋이생길수있어주의해야합니다.

1504 –02
git branch
16git branch Git 
작업흐름(줄기) / 작업에이름을붙인다
독립적으로 작업을 진행할 수있도록돕는작업흐름
마지막커밋을가리키는 포인터 (커밋흐름, 진행경로를 추적)
브랜치= 커밋흐름의 이름표
17Branch 없이개발하면생기는문제Git
브랜치가 없으면 되돌리기가 매우위험하다
•안정적으로 되돌릴 안전지점(safe point) 이없다.
•해시(hash) 기반으로 되돌리기는 어렵고실수하기 쉽다.
•잘못되면 작업물이 사라지거나 main을손상시킬 위험이크다.
18AI 시스템에서버전호환문제들Git
작업이많아지고 커밋이 많아질수록 생기는 문제점
AI 시스템에서 AI 모델별로적용할코드가다를수있다. 
실험이많아질수록 어떤버전 인지 알필요가있다
ex) 버전을가지고있어야하는 이유들
●현재서비스에 나가있는 모델+코드
●지금연구하고 있는모델+ 코드등버전별
●A/B테스트 등

19(실습) git checkout 과git branch Git 
코드를이전버전으로 되돌려보기
5. 추가작업을위해 branch 를생성
-hash 를통해이동하면 너무불편+ 추가작업위한바탕( branch)가필요하다
-Detached Head 해결
git branch develop

20git branch 이름은어떻게정해야할까?Git
브랜치이름기본규칙
1.형식: type/task-name(그룹형태)
a.복잡해지면area까지: type/ area/task-name (그룹형태)
2.단어는하이픈(-) 으로연결
3.공백, 대문자, 특수문자 ❌
4.이름만 보고 작업목적이 명확하게 보이도록
21git branch 이름은어떻게정해야할까?Git
브랜치종류(역할)에 따른prefix
feature —기능개발
-feature/user-profile
-feature/add-search-api
fix—버그수정
-fix/wrong-total-score
-fix/null-pointer-error
hotfix—운영긴급수정
-hotfix/payment-failure
refactor —구조개선
-refactor/split-preprocess-moduleexperiment —AI/ML 실험
-experiment/model-v2
-experiment/augmentation-test
docs—문서작업
-docs/update-api-spec
ci / infra —자동화& 인프라
-ci/add-github-actions
-infra/add-terraform-config
2204 –03
merge
conflict
23각자만든작업(branch)는어떻게합칠까?Git
gitmerge
두브랜치의작업내용을하나로합치는과정
gitconflict
두브랜치가같은파일의같은부분(hunk) 을수정했을때
Git은두개의코드가같은줄에있을때"어느쪽이맞는지" 결정불가
→ 개발자에게선택권을넘김
24Conflict 해결과정Git
Conflict는 "오류"가 아니다. Git이개발자에게 선택권을 넘긴것이다.
1. 두코드중어떤부분을살릴지결정
-내버전만살릴수도있음
-상대버전만살릴수도있음
-둘을합쳐새로운버전을만들수도있음
2. 충돌표시(<<<<<<<, =======, >>>>>>>) 제거
3. 수정된파일저장
4. 다시stage( gitadd) → commit(Merge커밋) 
25(실습) Conflict 파일Git
A 브랜치(현재) –B 브랜치(합칠 브랜치)
<<<<<<< HEAD
return f"{user} 님,  '{message}' 를 잘 받았습니다 ."
=======
return f"{user} 님, 서울 날씨는 '{message}' 잘 받았습니다 ."
>>>>>>> lecture/conflict-b
git switch start
git pull
uv sync
26(실습) git merge 와conflict 실습Git
git merge 와conflict
1. lecture/conflict-a branch 생성후agent.py 파일return 바꾸고커밋
2. lecture/conflict-b branch 생성후agent.py 파일return 바꾸고커밋
(1,2) 같은파일을
3. lecture/conflict-a 브랜치에lecture/conflict-b 브랜치를merge
4. conflict 발생
3. feature/embedding-service 에서develop 로합쳐보기

27(실습) git merge 와conflict 실습Git
git merge 와conflict
4. merge 실패conflict 상황

28Conflict 을줄이는방법Git
잦은Git conflict는 생산성과 코드안정성에 직접적으로 영향
작은단위로자주커밋하고자주푸시(Push/Pull) 하기
-Conflict의가장큰원인은 오래떨어져있던두타임라인이갑자기만날때 생김.
일정한merge 흐름
-브랜치의역할을나누고merge 하는브랜치를고정
기능단위로브랜치를짧게유지하기
-작업이길어질것같으면기능을분리
-브랜치는 3~5일안에 merge가목표
파일단위충돌위험을줄이기위한코드구조화(Clean code)
-Conflict는"같은 파일의 같은 줄 "이 바뀌어야 난다 .
→ 파일을 분리하면 conflict가 줄어든다 . 
29Conflict 을줄이는방법Git
잦은Git conflict는 생산성과 코드안정성에 직접적으로 영향
main/develop브랜치를더럽히지않기
-팀의중심브랜치(main/develop)가깨끗하면충돌도줄어듦.
-직접main에push금지
-PR 기반merge강제
-PR 템플릿으로커밋기준통일
merge전에미리차이(diff) 확인
-merge전에다음을통해conflict가능성을예측
컨벤션통일
-Prettier/ Black / ESLint등"자동포매터" 도입
-Conflict를많이만드는원인중하나는 줄바꿈, 들여쓰기, 공백, 포매팅차이
3004 -04
git flow
31Git branch 전략적으로사용하는방법Git
일관된 merge 흐름의필요성
conflict 는생산성을해친다= 개발자의의사결정을계속물어보게된다
역할과개발환경에맞는 일관된merge 흐름이필요하다
회사개발환경(사내개발환경/ 테스트환경/ 라이브환경)
32Git branch 전략Git flow Git
단순한브랜치전략을넘어개발의흐름을깔끔하게정리

33main  / develop 브랜치Git
배포하는 브랜치: main 
실제배포된 코드(production)
tag를통해실제배포된 버전들을 관리(정기/비정기인지)
메인배포인지 아니면서브배포인지
작업을합치는브랜치: develop
개발자들의 작업들을 합치는공간(중간단계개발통합) 
feature 브랜치들

34각자작업을진행하는브랜치Git
feature/, feat/
해야할작업이생김→ 이슈등록
develop 에서이슈에 대한feature 브랜치작성
이슈들에 대한처리

35QA, 테스트, 릴리즈직전작업Git
release
정기배포: QA, 문서화, 버그수정, 릴리즈노트
develop에서기능완료후분기
작업완료후main + develop 에머지+ Git Tag 추가
develop 에서바로main 으로가는게아니라중간단계에서
다듬는다.
개발초기단계, 라이브가없는단계에선굳이필요없습니다.

36(비정기) 배포하는브랜치: hotfix Git
main 에서바로분기해서 긴급수정브랜치
1. develop 에배포하면안될것들이있을경우
2. 운영중버그발견해서즉시수정필요
이럴때
main에서분기해서작업
완료후main + develop 모두병합
기존의작업을cherry pick 등으로
코드를(커밋)을가져다사용

37총정리Git 
Git작업흐름과되돌리기
branch필요성과 사용법/사례
-gitbranch각역할
merge/ conflict
-conflict해결법
-conflict를줄이는방법
Gitflow전략
-Gitflow를통한merge전략과 배포
www.upstage.ai © 2025 Upstage Co., Ltd.

