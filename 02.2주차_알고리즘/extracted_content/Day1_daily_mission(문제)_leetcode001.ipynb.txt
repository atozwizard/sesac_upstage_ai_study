# Day 1. 배열과 알고리즘으로 문제 해결하기 – 데일리 미션

이 노트북은 **배열과 기초 알고리즘 설계**를 연습하기 위한 데일리 미션용입니다.

## 🎯 학습 목표
- 배열의 인덱스 기반 접근 방식과 메모리 구조를 이해한다.
- 브루트 포스(Brute Force)와 해시맵(Hash Map) 알고리즘의 **시간복잡도 차이**를 체험한다.
- 같은 문제를 두 가지 방식으로 풀어보고, 어떤 상황에서 더 나은 방법을 선택해야 하는지 정리한다.

---
## 오늘의 문제: LeetCode #1 – Two Sum

정수 배열 `nums`와 정수 `target`이 주어질 때,
배열에서 **합이 `target`이 되는 서로 다른 두 수의 인덱스**를 반환하세요.

### 조건
- 각 입력에는 **정확히 하나의 해**만 존재합니다.
- 같은 원소를 두 번 사용할 수 없습니다.
- 반환 순서는 상관 없습니다.

### 예시
1. `nums = [2, 7, 11, 15]`, `target = 9` → 출력: `[0, 1]`
2. `nums = [3, 2, 4]`, `target = 6` → 출력: `[1, 2]`
3. `nums = [3, 3]`, `target = 6` → 출력: `[0, 1]`

### 제한 조건
- `2 <= nums.length <= 10^4`
- `-10^9 <= nums[i] <= 10^9`
- `-10^9 <= target <= 10^9`
- **단 하나의 정답만 존재**

---
아래 Step 1 → Step 3 순서대로 문제를 해결한 뒤, 마지막에 정리까지 완료해 주세요.

## 🛠️ Prerequisites
본 미션에서는 다음과 같은 Python 표준 라이브러리를 사용합니다.
* **`from typing import List`**: `nums` 배열의 타입을 명시하기 위해 사용합니다.
* 별도의 외장 라이브러리 설치 없이 기본 Python 환경에서 실행 가능합니다.

## Step 1. Brute Force로 Two Sum 풀어보기

가장 직관적인 방법은 **모든 쌍 `(i, j)`를 직접 비교**하는 것입니다.

### 요구 사항
- 이중 반복문을 사용해 `nums[i] + nums[j] == target` 인 쌍을 찾으세요.
- 정답이 되는 인덱스 두 개를 리스트로 반환하세요. (예: `[i, j]`)
- **시간복잡도 분석**: 왜 이 알고리즘이 `O(N^2)` 인지, 함수의 docstring 또는 아래 마크다운에 적어보세요.

from typing import List

def two_sum_bruteforce(nums: List[int], target: int) -> List[int]:
    """Two Sum 문제를 브루트 포스 방식으로 해결합니다.

    시간복잡도: #전체를 비교하기위해 인풋 n개를 n번만큼 n회 비교하니까 시간복잡도가 O(N^2)
        TODO: 왜 이 알고리즘의 시간복잡도가 O(N^2)인지 설명을 적어보세요.
    """

    # TODO: 이중 for 문을 사용해 모든 (i, j) 쌍을 확인하고,
    #       합이 target이 되는 인덱스를 찾아 반환하세요.
    #       정답이 하나만 존재한다고 가정해도 됩니다.
    
    for i in range(len(nums)):  # 첫번째 인덱스 숫자
        for j in range(i + 1, len(nums)): # 두번째 인덱스 숫자
            if nums[i] + nums[j] == target:
                return(nums[i],nums[j])   #인덱스 반환받아야하니까 return함수 // 출력이 아니라 반환하세요라고함

    #전체를 비교하기위해 인풋 n개를 n번만큼 n회 비교하니까 시간복잡도가 O(N^2)
    raise NotImplementedError
    



### ✅ 테스트 코드 (수정하지 말고, 위 함수를 구현한 뒤 실행해 보세요)

test_cases = [
    ([2, 7, 11, 15], 9, [0, 1]),
    ([3, 2, 4], 6, [1, 2]),
    ([3, 3], 6, [0, 1]),
]

for nums, target, expected in test_cases:
    result = two_sum_bruteforce(nums, target)
    print(f"nums={nums}, target={target} → result={result}, expected={expected}")


---
## Step 2. Hash Map을 이용해 O(N)으로 개선하기

이번에는 **dictionary(해시맵)** 를 사용해 시간복잡도를 `O(N)`으로 줄여봅니다.

### 아이디어 힌트
- 리스트를 앞에서부터 순회하면서, 현재 값 `num`에 대해 **필요한 값** `target - num` 을 계산합니다.
- 그 값이 이미 dictionary 안에 있다면, 두 인덱스를 바로 반환할 수 있습니다.
- 없다면, 현재 값과 인덱스를 dictionary에 저장합니다.

### 요구 사항
- dictionary를 사용해 **한 번의 순회**만으로 풀이해 보세요.
- 함수 안에 시간복잡도(`O(N)`)를 명시하고, Brute Force 방식과 무엇이 다른지 짧게 적어보세요.

def two_sum_hashmap(nums: List[int], target: int) -> List[int]:
    """Two Sum 문제를 해시맵 방식으로 해결합니다.

    시간복잡도: 리스트를 n개만큼 한번씩만 순회하면서 값을 찾으니 O(N)
        TODO: 왜 이 알고리즘의 시간복잡도가 O(N)인지 설명을 적어보세요.
    """
    # TODO: dict를 사용하여, 한 번의 순회로 정답을 찾는 코드를 작성해 보세요.
    # 예시 아이디어:
    #   - seen = {}
    #   - for i, num in enumerate(nums):
    #         need필요한 값 = target - num
    #         need필요한 값이 seen에 있는지 확인 if need in seen :
    #         없다면 현재 값과 인덱스를 seen에 저장 append?, return [seen[need]]
    
    seen = {} # 
    
    for i , num in enumerate(nums): #enumerate로 인덱스와 값을 동시에 순회,
        need = target - num
        if need in seen: #need가 seen에 있는지 확인,있으면
            return [seen[need],i] #있는 그 값의 인덱스, 인덱스 내놔
        seen[num] = i  #없으면 seen에 i인덱스에 need 구할때 넣은 num값을 넣어놔

    
# 거짓일때는?? 반환 안됨

#타겟값이 정해져 있어서 가능한거잖음. 값이 정해져 있을때에만 답을 찾는건가.
    #타겟이 주어지지 않는다면 n^2만큼 돌려서 타겟을 만든 다음, 검증해야하는?  
    #????
    # 무얼 찾아야 하는지 타켓이 명확할 때 사용할 수 있는 솔루션이겠다.
    raise NotImplementedError


### ✅ 테스트 코드 (Step 1과 동일한 테스트 케이스를 사용합니다)

for nums, target, expected in test_cases:
    result = two_sum_hashmap(nums, target)
    
    print(f"nums={nums}, target={target} → result={result}, expected={expected}")


---
## Step 3. Brute Force vs Hash Map 비교 정리

아래 마크다운 셀에 두 방식의 차이점을 정리해 보세요. (키워드만이 아니라 문장으로 설명해보면 좋습니다.)

### 비교 관점
- 접근 방식 차이 (어떻게 문제를 바라보는가?)
- 시간복잡도 비교 (`O(N^2)` vs `O(N)`)
- 메모리 사용량 (추가 자료구조 사용 여부)
- 실전에서 어떤 상황에서 어떤 방식을 선택할지

---
아래 셀을 직접 수정해서 본인의 정리를 작성하세요.

### ✏️ 정리 (학생 작성)

- 브루트 포스 Brute Force 방식: 하나하나 다 해보는 것이다. 자물쇠번호를 풀기위해 0000부터 9999가지 전부 대입하는 것과 같다. 따라서, 시도할 리스트가 길어지면 시간이 어마어마해진다.(N^2)
  - 데이터가 10배 늘어나면 연산횟수는 100배
- 해시맵 Hash Map 방식: 한 번 본 숫자를 해시맵이라는 메모장에 적어두는 방식. 리스트를 딱 한 번만 훑는다. 짝꿍(타겟-현재숫자)이 메모장에 적혀있는지를 확인해, 입구에서 방명록을 확인하고 해당 번호로 가는 것과 같다.
  - 데이터가 10배 늘어나면 연산횟수도 10배 
- 두 방식의 공통점 & 차이점: 이미 본 데이터를 기억하냐, 매번 새로 찾아 헤매냐
- 이중 반복문으로 모든 쌍을 검사하냐, 단일 반복문과 메모리 활용으로 한번에 가냐
  - 시간복잡도: N^2, N
  - 메모리 사용: 추가메모라를 거의 안쓰지만/ 해시맵 저장공간이 추가로 필요하다
  - 구현 난이도: 브루트포스방식이 냅다 돌리면 되니까 구현은 쉬워보였다.
  - 지금이야 이중문을 썼다지만, 삼중 사중 얼마든지 돌릴 수 있지않나. 그러나 시간이 오래걸린다는 것은 곧 비용과도 직결되는 문제이니 해시맵을 이해해보려 노력해야겠다.
  - 실제로 내가 쓴다면?
- 데이터 개수 (N),브루트 포스 (O(N2)),해시맵 (O(N)),차이
    100개,"10,000번 연산 (0.0001초)",100번 연산 (찰나),체감 안 됨
    "10,000개",1억 번 연산 (약 1초),"10,000번 연산 (0.0001초)",1만 배 차이
    "100,000개",100억 번 연산 (약 1.6분),"100,000번 연산 (0.001초)",약 10만 배 차이
    "1,000,000개",1조 번 연산 (약 2.7시간),"1,000,000번 연산 (0.01초)",넘사벽
해시맵을 써야겠네.

---
## Step 4. 제출 전 체크리스트
- [ ] Brute Force 코드가 정상 동작한다.
- [ ] Hash Map 코드가 정상 동작한다.
- [ ] 두 방식의 시간복잡도와 차이에 대한 나만의 설명을 적었다.
- [ ] 예시 테스트 케이스 결과가 문제 설명과 일치한다.
- [ ] (과제용) 실행 결과를 캡처해 별도 제출 또는 첨부 준비를 했다.

수고하셨습니다! 😄


###**콘텐츠 라이선스**
<font color='red'><b>**(주)업스테이지가 제공하는 모든 교육 콘텐츠의 지식재산권은
운영 주체인 (주)업스테이지 또는 해당 저작물의 적법한 관리자에게 귀속되어 있습니다.**</b></font>

콘텐츠 일부 또는 전부를 **복사, 복제, 판매, 재판매 공개, 공유** 등을 할 수 없습니다. 유출될 경우 지식재산권 침해에 대한 책임을 부담할 수 있습니다.

유출에 해당하여 금지되는 행위의 예시는 다음과 같습니다.
* 콘텐츠를 재가공하여 온/오프라인으로 공개하는 행위
* 콘텐츠의 일부 또는 전부를 이용하여 인쇄물을 만드는 행위
* 콘텐츠의 전부 또는 일부를 녹취 또는 녹화하거나 녹취록을 작성하는 행위
* 콘텐츠의 전부 또는 일부를 스크린 캡쳐하거나 카메라로 촬영하는 행위
* 지인을 포함한 제3자에게 콘텐츠의 일부 또는 전부를 공유하는 행위
* 다른 정보와 결합하여 Upstage Education의 콘텐츠임을 알아볼 수 있는 저작물을 작성, 공개하는 행위
* 제공된 데이터의 일부 혹은 전부를 Upstage Education 프로젝트/실습 수행 이외의 목적으로 사용하는 행위