# Day 1. 배열과 알고리즘으로 문제 해결하기 – 데일리 미션

이 노트북은 **배열과 기초 알고리즘 설계**를 연습하기 위한 데일리 미션용입니다.

## 🎯 학습 목표
- 배열의 인덱스 기반 접근 방식과 메모리 구조를 이해한다.
- 브루트 포스(Brute Force)와 해시맵(Hash Map) 알고리즘의 **시간복잡도 차이**를 체험한다.
- 같은 문제를 두 가지 방식으로 풀어보고, 어떤 상황에서 더 나은 방법을 선택해야 하는지 정리한다.

---
## 오늘의 문제: LeetCode #1 – Two Sum

정수 배열 `nums`와 정수 `target`이 주어질 때,
배열에서 **합이 `target`이 되는 서로 다른 두 수의 인덱스**를 반환하세요.

### 조건
- 각 입력에는 **정확히 하나의 해**만 존재합니다.
- 같은 원소를 두 번 사용할 수 없습니다.
- 반환 순서는 상관 없습니다.

### 예시
1. `nums = [2, 7, 11, 15]`, `target = 9` → 출력: `[0, 1]`
2. `nums = [3, 2, 4]`, `target = 6` → 출력: `[1, 2]`
3. `nums = [3, 3]`, `target = 6` → 출력: `[0, 1]`

### 제한 조건
- `2 <= nums.length <= 10^4`
- `-10^9 <= nums[i] <= 10^9`
- `-10^9 <= target <= 10^9`
- **단 하나의 정답만 존재**

---
아래 Step 1 → Step 3 순서대로 문제를 해결한 뒤, 마지막에 정리까지 완료해 주세요.

## 🛠️ Prerequisites
본 미션에서는 다음과 같은 Python 표준 라이브러리를 사용합니다.
* **`from typing import List`**: `nums` 배열의 타입을 명시하기 위해 사용합니다.
* 별도의 외장 라이브러리 설치 없이 기본 Python 환경에서 실행 가능합니다.

## Step 1. Brute Force로 Two Sum 풀어보기

가장 직관적인 방법은 **모든 쌍 `(i, j)`를 직접 비교**하는 것입니다.

### 요구 사항
- 이중 반복문을 사용해 `nums[i] + nums[j] == target` 인 쌍을 찾으세요.
- 정답이 되는 인덱스 두 개를 리스트로 반환하세요. (예: `[i, j]`)
- **시간복잡도 분석**: 왜 이 알고리즘이 `O(N^2)` 인지, 함수의 docstring 또는 아래 마크다운에 적어보세요.

from typing import List

def two_sum_bruteforce(nums: List[int], target: int) -> List[int]:
    """Two Sum 문제를 브루트 포스 방식으로 해결합니다.

    시간복잡도:
        TODO: 왜 이 알고리즘의 시간복잡도가 O(N^2)인지 설명을 적어보세요.
    """
    # TODO: 이중 for 문을 사용해 모든 (i, j) 쌍을 확인하고,
    #       합이 target이 되는 인덱스를 찾아 반환하세요.
    #       정답이 하나만 존재한다고 가정해도 됩니다.
    raise NotImplementedError


### ✅ 테스트 코드 (수정하지 말고, 위 함수를 구현한 뒤 실행해 보세요)

test_cases = [
    ([2, 7, 11, 15], 9, [0, 1]),
    ([3, 2, 4], 6, [1, 2]),
    ([3, 3], 6, [0, 1]),
]

for nums, target, expected in test_cases:
    result = two_sum_bruteforce(nums, target)
    print(f"nums={nums}, target={target} → result={result}, expected={expected}")


---
## Step 2. Hash Map을 이용해 O(N)으로 개선하기

이번에는 **dictionary(해시맵)** 를 사용해 시간복잡도를 `O(N)`으로 줄여봅니다.

### 아이디어 힌트
- 리스트를 앞에서부터 순회하면서, 현재 값 `num`에 대해 **필요한 값** `target - num` 을 계산합니다.
- 그 값이 이미 dictionary 안에 있다면, 두 인덱스를 바로 반환할 수 있습니다.
- 없다면, 현재 값과 인덱스를 dictionary에 저장합니다.

### 요구 사항
- dictionary를 사용해 **한 번의 순회**만으로 풀이해 보세요.
- 함수 안에 시간복잡도(`O(N)`)를 명시하고, Brute Force 방식과 무엇이 다른지 짧게 적어보세요.

def two_sum_hashmap(nums: List[int], target: int) -> List[int]:
    """Two Sum 문제를 해시맵 방식으로 해결합니다.

    시간복잡도:
        TODO: 왜 이 알고리즘의 시간복잡도가 O(N)인지 설명을 적어보세요.
    """
    # TODO: dict를 사용하여, 한 번의 순회로 정답을 찾는 코드를 작성해 보세요.
    # 예시 아이디어:
    #   - seen = {}
    #   - for i, num in enumerate(nums):
    #         필요한 값 = target - num
    #         필요한 값이 seen에 있는지 확인
    #         없다면 현재 값과 인덱스를 seen에 저장
    raise NotImplementedError


### ✅ 테스트 코드 (Step 1과 동일한 테스트 케이스를 사용합니다)

for nums, target, expected in test_cases:
    result = two_sum_hashmap(nums, target)
    print(f"nums={nums}, target={target} → result={result}, expected={expected}")


---
## Step 3. Brute Force vs Hash Map 비교 정리

아래 마크다운 셀에 두 방식의 차이점을 정리해 보세요. (키워드만이 아니라 문장으로 설명해보면 좋습니다.)

### 비교 관점
- 접근 방식 차이 (어떻게 문제를 바라보는가?)
- 시간복잡도 비교 (`O(N^2)` vs `O(N)`)
- 메모리 사용량 (추가 자료구조 사용 여부)
- 실전에서 어떤 상황에서 어떤 방식을 선택할지

---
아래 셀을 직접 수정해서 본인의 정리를 작성하세요.

### ✏️ 정리 (학생 작성)

- Brute Force 방식:
  -
- Hash Map 방식:
  -
- 두 방식의 공통점 & 차이점:
  - 시간복잡도:
  - 메모리 사용:
  - 구현 난이도:
  - 실제로 내가 쓴다면?


---
## Step 4. 제출 전 체크리스트
- [ ] Brute Force 코드가 정상 동작한다.
- [ ] Hash Map 코드가 정상 동작한다.
- [ ] 두 방식의 시간복잡도와 차이에 대한 나만의 설명을 적었다.
- [ ] 예시 테스트 케이스 결과가 문제 설명과 일치한다.
- [ ] (과제용) 실행 결과를 캡처해 별도 제출 또는 첨부 준비를 했다.

수고하셨습니다! 😄


###**콘텐츠 라이선스**
<font color='red'><b>**(주)업스테이지가 제공하는 모든 교육 콘텐츠의 지식재산권은
운영 주체인 (주)업스테이지 또는 해당 저작물의 적법한 관리자에게 귀속되어 있습니다.**</b></font>

콘텐츠 일부 또는 전부를 **복사, 복제, 판매, 재판매 공개, 공유** 등을 할 수 없습니다. 유출될 경우 지식재산권 침해에 대한 책임을 부담할 수 있습니다.

유출에 해당하여 금지되는 행위의 예시는 다음과 같습니다.
* 콘텐츠를 재가공하여 온/오프라인으로 공개하는 행위
* 콘텐츠의 일부 또는 전부를 이용하여 인쇄물을 만드는 행위
* 콘텐츠의 전부 또는 일부를 녹취 또는 녹화하거나 녹취록을 작성하는 행위
* 콘텐츠의 전부 또는 일부를 스크린 캡쳐하거나 카메라로 촬영하는 행위
* 지인을 포함한 제3자에게 콘텐츠의 일부 또는 전부를 공유하는 행위
* 다른 정보와 결합하여 Upstage Education의 콘텐츠임을 알아볼 수 있는 저작물을 작성, 공개하는 행위
* 제공된 데이터의 일부 혹은 전부를 Upstage Education 프로젝트/실습 수행 이외의 목적으로 사용하는 행위