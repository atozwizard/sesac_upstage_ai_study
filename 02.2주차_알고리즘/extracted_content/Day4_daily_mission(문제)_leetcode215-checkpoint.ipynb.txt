# Day 4. 힙과 이진 탐색으로 문제 해결하기 – 데일리 미션 (Kth Largest)

이 노트북은 **힙(Priority Queue)** 를 활용해 LeetCode **#215 – Kth Largest Element in an Array**
문제를 푸는 데일리 미션용입니다.

## 🎯 학습 목표
- 전체 정렬을 하지 않고도 **k번째로 큰 원소**를 찾는 방법을 이해한다.
- `heapq` 모듈을 활용하여 **min-heap 기반 top-k 패턴**을 구현한다.
- 정렬(`O(n log n)`) vs 힙(`O(n log k)`) vs QuickSelect(평균 `O(n)`)의
  시간복잡도 차이를 설명할 수 있다.

---
## 문제: Kth Largest Element in an Array

> 정수 배열 `nums` 와 정수 `k` 가 주어질 때,
> 배열을 내림차순 정렬했을 때의 **k번째로 큰 값(Kth largest)** 를 반환하세요.

- "서로 다른 값의 k번째"가 아니라, **정렬 순서 기준으로 k번째**입니다.
- 전체를 정렬하지 않고도 풀 수 있을까요?

### 예시
1. `nums = [3,2,1,5,6,4], k = 2` → 출력: `5`
2. `nums = [3,2,3,1,2,4,5,5,6], k = 4` → 출력: `4`

### 제한 조건 (문제 요약)
- `1 <= k <= nums.length <= 10^5`
- `-10^4 <= nums[i] <= 10^4`

---
이제 아래 **Step 1 → Step 4** 순서로 미션을 진행해 주세요.

## 🛠️ Prerequisites
본 미션은 효율적인 데이터 처리를 위해 파이썬 내장 모듈을 활용합니다.
* **`import heapq`**: 최소 힙(min-heap)을 사용하여 $O(n \log k)$의 시간복잡도로 문제를 해결합니다.
* **`from typing import List`**: 리스트 데이터의 타입을 명시하기 위해 사용합니다.
* 별도의 설치 없이 Python 3.x 환경의 표준 라이브러리만으로 실행 가능합니다.

## Step 1. 문제 이해 및 접근 방식 비교

먼저, 이 문제를 풀 수 있는 여러 가지 방법을 떠올려 봅시다.

### 대표적인 세 가지 접근
1. **전체 정렬 방식**
   - `nums.sort()` 로 전체 정렬 후, 뒤에서 k번째 원소를 꺼낸다.
   - 시간복잡도: `O(n log n)`

2. **min-heap 기반 top-k 방식** (오늘 구현할 방법)
   - 크기가 **항상 k 이하**가 되도록 min-heap을 유지한다.
   - heap 크기가 k를 초과하면 가장 작은 값을 pop한다.
   - 최종적으로 heap의 루트(가장 작은 값)가 "k번째로 큰 값"이 된다.
   - 시간복잡도: `O(n log k)`

3. **QuickSelect (선택 알고리즘)**
   - 퀵 정렬의 `partition` 아이디어로 평균 `O(n)`에 k번째 원소를 찾는다.
   - 구현은 조금 복잡하지만, 이론적으로 더 빠르다(평균).

아래에 본인이 이해한 세 방법의 차이를 간단히 정리해 보세요.

### ✏️ 세 가지 접근 방식 요약 (학생 작성)

- 전체 정렬 방식 (장점/단점):
  - 한 번 정렬해두면, 다른 순위의 값도 O(1)에 찾을 수 있다
  - k번째만 궁금한데, 나머지 모든 숫자의 순서까지 모두 정리해야한다 O(N*logN)
    
- min-heap 방식 (장점/단점):
  - 크기가 k인 힙을 유지할 때, 가장 작은 값인 루트가 k가 된다
  - 배열 전체를 기억할 필요없이, k개의 공간이 필요함
  - k가 아주 크다면 전체 정렬과 속도차이가 거의 없다 O(N*logk)

- QuickSelect (장점/단점, 느낌):
  - 이진탐색과 유사하다!!
  - 시간복잡도 O(N) 
  - 그러나 한쪽으로 노드가 쏠린경우엔 O(N*N) 이 될 수도 있다.


---
## Step 2. `heapq` 로 min-heap 기반 Kth Largest 구현하기

파이썬에서는 `heapq` 모듈이 **min-heap** 을 제공합니다.

### 아이디어 (top-k 패턴)
- 빈 배열 `heap = []` 를 준비합니다.
- `nums` 의 원소들을 하나씩 보면서 **heap에 push** 합니다.
- 만약 heap의 크기가 `k` 를 초과하면, `heappop` 으로 **가장 작은 값을 제거**합니다.
- 모든 원소를 처리한 뒤, heap[0] (루트)가 바로 **k번째로 큰 원소**가 됩니다.

아래 템플릿을 참고해서 `findKthLargest` 메서드를 완성해 보세요.

from typing import List
import heapq

##퀵셀렉트인가?? 데일리미션의 그것과 비슷한데

class SolutionHeap:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        heap = []  #heap을 빈 리스트로 지정
        for num in nums: #nums 순회하면서
            heapq.heappush(heap, num) #매 원소마다 heappush(최소힙 유지), 
            """heappush함수는 값을 단순히 리스트 끝에 넣는 것이 아니라, 
            최소힙의 성질을 유지하도록 내부적으로 재배치작업을 자동으로 수행하비다"""
            
            if len(heap) > k : #heap크기가 k를 초과하면 가장 작은 값 제거
                heapq.heappop(heap)  
                """값을 빼는 순간 가장 뒤에있던 값을 루트로 가져온 뒤
                                        아래로 슥 내려보내며 다시 최소힙 유지"""
               
        return heap[0]  #반복이 끝나면 루트값 내놔(최소값, 이 경우 k번째 큰 값)

        """heapq 함수들을 통해서만 리스트를 조작한다면, 그 리스트는 항상 최소힙
        상태를 유지하게 된다!!
        
        전체 숫자 N개를 다 훑는다.
            이 힙은 항상 크기 k를 유지한다. logk. 따라서 시간복잡도 O(N*logk)"""



        
        """min-heap을 사용해 k번째로 큰 원소를 찾는 함수입니다.

        아이디어:
            - 크기가 항상 k 이하가 되도록 min-heap을 유지합니다.
            - heap에 원소를 push 하다가, 크기가 k+1이 되면 가장 작은 값을 pop합니다.
            - 최종적으로 heap[0] 에 남는 값이 k번째로 큰 값입니다.

        시간복잡도:
            - 각 원소마다 push/pop 이 최대 한 번씩 일어나며, 각 연산은 O(log k)이므로
              전체 시간복잡도는 O(n log k) 입니다.
        """
        # TODO: 위 설명에 따라 코드를 직접 작성해 보세요.
        #   1. 빈 리스트를 heap으로 사용 (heap = [])
        #   2. nums를 순회하면서, 매 원소마다 heappush
        #   3. 만약 len(heap) > k 가 되면 heappop으로 가장 작은 값 제거
        #   4. 반복이 끝난 뒤 heap[0] 을 반환
        raise NotImplementedError


### ✅ 테스트 코드 (수정하지 말고, 위 함수를 완성한 뒤 실행해 보세요)

추가로 본인이 직접 케이스를 1~2개 더 넣어도 좋습니다.

def run_tests_heap():
    sol = SolutionHeap()
    tests = [
        ([3,2,1,5,6,4], 2, 5),
        ([3,2,3,1,2,4,5,5,6], 4, 4),
        ([1], 1, 1),
        ([2,1], 1, 2),  # 가장 큰 값
    ]

    for nums, k, expected in tests:
        result = sol.findKthLargest(nums, k)
        print(f"nums={nums}, k={k} → result={result}, expected={expected}")

run_tests_heap()


---
## Step 3. (선택) QuickSelect로 평균 O(n)에 도전하기

여유가 있다면, QuickSelect 방식으로도 같은 문제를 풀어 보세요.

### 아이디어 매우 간단 요약
- 퀵 정렬의 `partition` 과 비슷하게, 피벗을 기준으로 배열을 두 부분으로 나눕니다.
- 피벗의 정렬상 위치 `idx` 가 우리가 찾는 `k번째` 위치인지 확인합니다.
  - `idx` 가 목표보다 왼쪽/오른쪽이면, 그쪽 부분 배열에 대해서만 재귀적으로 반복합니다.
- 평균적으로 `O(n)` 에 k번째 원소를 찾을 수 있습니다.

완전히 구현하기 부담스럽다면, **의사 코드 수준으로라도** 아래 셀에 정리해 보세요.

# class SolutionQuickSelect:
#     def findKthLargest_quickselect(self, nums: List[int], k: int) -> int:
#         heap = []
#         first = 0
#         last = len(list) -1
        
#         while first <= last: #first 와 last의 거리를 좁혀갈거야
#             mid = (first + last) // 2
#             if list[mid] == k: #mid인덱스 값이 k와 같으면 mid 인덱스를 내놔
#                 return mid
#             elif list[mid] < k: #mid인덱스 값이 k보다 작으면, 시작인덱스를 mid인덱스 오른쪽1칸에서 다시
#                 first = mid + 1
#             else:
#                 last = mid -1 #mid인덱스 값이 k보다 크면, 끝 인덱스를 mid인덱스 왼쪽1칸으로 다시
#         return -1

"""문제!, nums는 정렬이 되어있지 않다! 그럼 먼저 num를 정렬하면 되지!!
--->>>NO!! 퀵셀릭트quick select 라는것은, 임의의 피벗(기준점, 중심점)을 정해 정렬했을 때의
    진짜 인덱스를 찾아내고, k와 비교하며 범위를 좁혀야한다.  ?????네????? """

class SolutionQuickSelect:
    def findKthLargest_quickselect(self, nums: List[int], k: int) -> int:
#k번째 큰 인덱스는, len(nums)-k 해야 정렬한 리스트에서 인덱스에서 찾을 수 있음
        target = len(nums)-k
        left, right = 0, len(nums)-1 #초기 범위 설정, nums의 맨앞부터 맨뒤

        while left <= right:
            p_idx = self.partition(nums, left, right)#피벗 인덱스는 반환받은 인덱스i이다

            if p_idx == target:
                return nums[p_idx]

            elif p_idx < target:
                left = p_idx + 1
            else: # p_idx > target
                right = p_idx - 1
        return -1 #찾는게 없다! 뭔가 잘못됨!
        
        # 랜덤.피벗인덱스선택(p_idx)
        # while P_idx를 기준으로 삼고 이보다 작으면 왼쪽, 크면 오른쪽으로 둘거야:
        #     partition() 을 먼저 수행해서 p_idx의 인덱스를 내놔
        #     if p_idx = k 이면 retrun p_idx
        #     if p_idx < k **k보다 왼쪽에 있으면** 이면 한칸 오른쪽에서 탐색해
        #     if p_idx > k **k보다 오른쪽에 있으면** 이면 한칸 왼쪽에서 탐색해

    def partition(self, nums:List[int], left:int, right:int)  -> int:
        #랜덤인덱스 피벗 뽑아, 오른쪽 끝에것과 교체-nums[right]
        rand_idx = random.randint(left, right)
        nums[rand_idx], nums[right] = nums[right], nums[rand_idx]
        #nums[right]를 p 피벗,기준값으로
        p = nums[right]
        #투포인터
        i = left

        for j in range(left,right): #for루프를 돌면서 정렬을 할것이다!
            if nums[j] <= p: #p 보다 작거나 같은 숫자발견하면
                nums[i],nums[j] = nums[j],nums[i] #발견한 숫자와 i와 교체??
                i += 1 
        #nums[j]가 p보다 크다면, 아무것도 안하고 j만 다음칸으로 넘어간다

        #루프가 끝나면 인덱스0 부터 인덱스i-1까지 모두 p보다 작은 수
        #인덱스 i에 p가 들어가야한다
        #nums[right]=p 이므로, 인덱스 i와 right를 교체
        nums[i],nums[right] = nums[right],nums[i]
        #p가 들어간 인덱스i를 반환
        return i
    
   




        """(선택) QuickSelect로 k번째 큰 원소를 찾는 함수입니다.

        TODO:
            - partition(분할) 함수를 내부에 정의한 뒤,
              재귀 또는 while 루프로 quickselect를 구현해 보세요.
            - 구현이 부담된다면, pass로 두고 주석/마크다운으로만 아이디어를 정리해도 좋습니다.
        """
        # TODO: QuickSelect 구현에 도전해보고 싶다면 이 부분을 채워보세요.
        raise NotImplementedError


---
## Step 4. 시간복잡도 분석 및 정리

아래에 **정렬 vs 힙 vs QuickSelect** 의 시간복잡도와,
실제 코딩 테스트/실무에서 어떤 방식을 선택할지에 대한 생각을 정리해 보세요.

### ✏️ 정리 (학생 작성)

- 전체 정렬 방식의 시간복잡도와 특징:
  -O(NlogN), 한 번 정렬해두면 이진 탐색도 할 수 있고 무엇이든 찾기 쉽다
  -데이터가 많아질수록 힙이나 퀵셀렉트보다 느리다
  모든 데이터의 순서가 중요할 때, 데이터를 한 번 정렬해두고 여러번 검색해야 할 때
  
- min-heap(top-k) 방식의 시간복잡도와 특징:
  -O(Nlogk), 데이터를 다 줄세우지 않고!, 누가 제일 큰지,작은지만 관리하는 느슨한 정렬상태를 유지하는.
  - 완전 정렬보다 빠르다
  - 새로운 데이터가 추가되는 상황에서도 최소값/최대값을 일정하게 뺄 수 있다 O(logN)
  - 실시간으로 우선순위가 높은 데이터를 처리해야 할 때(응급실), 데이터가 계속 들어오고 나가는 상황일 때

- QuickSelect의 평균/최악 시간복잡도와 특징:
  -O(N)/O(N*N), 정렬의 원리를 이용하되, target이 되는 k번째만 탐색
  - 임의의 피벗(기준점)을 기준으로 큰 쪽이나 작은 쪽, 한 쪽만 파고 들어감
  - 나머지 절반의 순서가 어떻게 되든 상관하지 않기 때문에 엄청 빠름
  - 다른 숫자는 관심 없고, 딱 target만 알고 싶을 때
- 내가 이 문제를 다시 푼다면 어떤 방식을 선택할지, 그 이유:
  -경우를 잘 따져봐야지 않을까? 데이터가 너무 많지만 않다면 정렬을, 계속 들어온다면 힙을

---
## ✅ 제출 전 체크리스트
- [ ] 전체 정렬을 사용하지 않고 min-heap으로 문제를 해결했다.
- [ ] heap 크기를 k로 유지하는 로직이 올바르게 구현되었다.
- [ ] 예제/엣지 케이스 테스트가 정상적으로 통과된다.
- [ ] 시간복잡도 `O(n log k)` 을 설명할 수 있다.
- [ ] (선택) QuickSelect 아이디어를 간단히라도 정리해 보았다.

수고 많았습니다! 🙂 이제 회전된 정렬 배열에서의 이진 탐색을 다루는 심화 미션으로 넘어가 봅시다.

###**콘텐츠 라이선스**
<font color='red'><b>**(주)업스테이지가 제공하는 모든 교육 콘텐츠의 지식재산권은
운영 주체인 (주)업스테이지 또는 해당 저작물의 적법한 관리자에게 귀속되어 있습니다.**</b></font>

콘텐츠 일부 또는 전부를 **복사, 복제, 판매, 재판매 공개, 공유** 등을 할 수 없습니다. 유출될 경우 지식재산권 침해에 대한 책임을 부담할 수 있습니다.

유출에 해당하여 금지되는 행위의 예시는 다음과 같습니다.
* 콘텐츠를 재가공하여 온/오프라인으로 공개하는 행위
* 콘텐츠의 일부 또는 전부를 이용하여 인쇄물을 만드는 행위
* 콘텐츠의 전부 또는 일부를 녹취 또는 녹화하거나 녹취록을 작성하는 행위
* 콘텐츠의 전부 또는 일부를 스크린 캡쳐하거나 카메라로 촬영하는 행위
* 지인을 포함한 제3자에게 콘텐츠의 일부 또는 전부를 공유하는 행위
* 다른 정보와 결합하여 Upstage Education의 콘텐츠임을 알아볼 수 있는 저작물을 작성, 공개하는 행위
* 제공된 데이터의 일부 혹은 전부를 Upstage Education 프로젝트/실습 수행 이외의 목적으로 사용하는 행위