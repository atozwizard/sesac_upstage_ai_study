 
 
 
[
개발환경
 
구성
]
 
코랩세션
 
Wrap
 
Up
 
리포트
 
작성팀:
 
6조
 
이영기
 
Wrap
 
Up
 
리포트
 
작성
 
내용
 
1)
 
논의
 
주제
 
a)
 
보라색으로
 
작성된
 
주제는
 
예시
 
주제로,
 
팀
 
내
 
논의하고
 
싶은
 
주제가
 
있다면
 
해당
 
주제로
 
논의해주세요!
 
2)
 
팀원별
 
핵심
 
아이디어
 
3)
 
논의
 
과정
 
4)
 
최종
 
논의
 
결과
 
및
 
회고
 
 
공통
 
예시
 
주제
 
(Day
 
01
 
-
 
Day
 
05)
 
 
Day
 
01
 
코랩
 
세션
 
 
오늘
 
하루
 
동안
 
겪은
 
파란만장한
 
과정은
 
단순한
 
설치기가
 
아니라,
 
**'개발
 
환경의
 
두
 
세계(
Linux
와
 
Windows)
를
 
넘나든
 
모험기'**와
 
같습니다
 
 
초기
 
환경
 
구축:
 
WSL2
와
 
Warp
 
터미널)
 
오늘의
 
시작은
 
리눅스
 
기반
 
개발
 
환경
 
구축이었습니다.
 
윈도우
 
내부에
 
**WSL2(Ubuntu)**
를
 
설치하고,
 
이를
 
시각적으로
 
제어하기
 
위해
 
Warp
 
터미널
을
 
연동했습니다.
 
●
 
작업
 
내용:
 
Ubuntu
 
환경에서
 
uv
를
 
사용해
 
가상환경(
.venv
)을
 
생성하고,
 
FastAPI
와
 
Loguru
 
등
 
필수
 
패키지를
 
설치했습니다.
 
●
 
연동:
 
파이참(
PyCharm)
의
 
인터프리터를
 
WSL
 
내부의
 
파이썬
 
경로로
 
지정하여
 
개발
 
준비를
 
마쳤습니다.
 
2.
 
발생한
 
문제:
 
환경
 
혼선과
 
경로
 
에러
 
 
*저작권
 
주의
 
(주)업스테이지가
 
제공하는
 
모든
 
교육
 
콘텐츠의
 
지식재산권은
 
운영
 
주체인
 
(주)업스테이지에게
 
귀속되어
 
있습니다.
 
콘텐츠
 
일부
 
또는
 
전부를
 
복사,
 
복제,
 
판매,
 
재판매
 
공개,
 
공유
 
등을
 
할
 
수
 
없습니다.
 

 
 
실습
 
진행
 
중,
 
윈도우
 
실행
 
파일과
 
리눅스
 
파일
 
시스템
 
간의
 
경로
 
충돌이
 
발생했습니다.
 
●
 
에러
 
상황:
 
파이참에서
 
윈도우
 
경로에
 
설치된
 
uv.exe
를
 
사용하여
 
리눅스
 
파일
 
시스템(
\\wsl$\home\...
)
 
내부의
 
프로젝트를
 
제어하려
 
시도했습니다.
 
●
 
결과:
 
CreateProcess
 
error=267,
 
디렉터리
 
이름이
 
올바르지
 
않습니다
라는
 
시스템
 
에러가
 
발생했습니다.
 
이는
 
윈도우
 
바이너리가
 
리눅스
 
네이티브
 
경로를
 
직접
 
실행할
 
수
 
없기
 
때문에
 
발생하는
 
전형적인
 
경로
 
매핑
 
문제입니다.
 
3.
 
환경
 
전환:
 
CMD
와
 
D
드라이브로의
 
이전\
 
복잡한
 
경로
 
문제를
 
해결하기
 
위해,
 
개발
 
환경을
 
리눅스(
WSL)
에서
 
윈도우(
CMD)
로
 
완전히
 
이전하기로
 
결정했습니다.
 
●
 
데이터
 
이동:
 
프로젝트
 
파일을
 
윈도우
 
파일
 
시스템인
 
D
드라이브로
 
옮겼습니다.
 
●
 
환경
 
재구축:
 
기존
 
리눅스용으로
 
생성되었던
 
.venv
 
폴더는
 
윈도우의
 
python.exe
와
 
호환되지
 
않으므로,
 
uv
 
venv
 
명령을
 
통해
 
윈도우용
 
가상환경으로
 
대체(
Replace)
했습니다.
 
●
 
패키지
 
재설치:
 
윈도우
 
환경에
 
맞춰
 
uv
 
add
 
loguru
 
uvicorn
 
fastapi
를
 
실행하여
 
의존성
 
라이브러리를
 
다시
 
구성했습니다.
 
4.
 
로직
 
구현
 
및
 
로깅
 
적용
 
 
환경
 
구축
 
후,
 
FastAPI
를
 
활용한
 
피보나치
 
수열
 
API
 
코드를
 
작성했습니다.
 
●
 
Loguru
 
적용:
 
표준
 
print
 
문
 
대신
 
loguru
 
라이브러리를
 
도입했습니다.
 
계산
 
시작과
 
끝은
 
logger.info
로,
 
반복문
 
내부의
 
변수
 
변화는
 
logger.debug
로
 
기록하도록
 
설계했습니다.
 
●
 
목적:
 
프로그램
 
실행
 
흐름을
 
가시화하고,
 
추후
 
디버깅
 
시
 
각
 
단계의
 
상태
 
값을
 
추적하기
 
위함입니다.
 
5.
 
최종
 
실행
 
및
 
검증
 
 
가상환경을
 
활성화(
.venv\Scripts\activate
)한
 
뒤,
 
서버
 
엔진인
 
Uvicorn
을
 
사용하여
 
API
 
서버를
 
구동했습니다.
 
●
 
명령어:
 
uvicorn
 
main:app
 
--reload
 
*저작권
 
주의
 
(주)업스테이지가
 
제공하는
 
모든
 
교육
 
콘텐츠의
 
지식재산권은
 
운영
 
주체인
 
(주)업스테이지에게
 
귀속되어
 
있습니다.
 
콘텐츠
 
일부
 
또는
 
전부를
 
복사,
 
복제,
 
판매,
 
재판매
 
공개,
 
공유
 
등을
 
할
 
수
 
없습니다.
 

 
 
●
 
트러블슈팅:
 
명령어
 
끝에
 
불필요한
 
기호(
:
)가
 
포함되어
 
옵션
 
인식
 
에러가
 
발생했으나,
 
이를
 
수정하여
 
정상
 
구동을
 
확인했습니다.
 
●
 
최종
 
확인:
 
브라우저에서
 
http://127.0.0.1:8000/fib/10
에
 
접속하여
 
JSON
 
응답값(
{"value":
 
55}
)을
 
수신했으며,
 
터미널을
 
통해
 
실시간으로
 
출력되는
 
로깅
 
데이터의
 
무결성을
 
검증하며
 
세션을
 
종료했습니다.
 
 
:
 
"결국
 
오늘
 
과정의
 
핵심은
 
OS
 
환경에
 
맞는
 
정확한
 
인터프리터
 
경로
 
설정
과
 
가상환경의
 
독립성
 
확보
였습니다.
 
환경이
 
충돌할
 
때는
 
에러가
 
발생한
 
지점의
 
파일
 
시스템
 
권한과
 
경로를
 
먼저
 
확인하는
 
것이
 
가장
 
빠른
 
해결책임을
 
확인했습니다."
 
 
 
Day
 
02
 
코랩
 
세션
 
 
 
소스트리를
 
버리고
 
안전을
 
선택하다
 
1.
 
내가
 
겪은
 
문제점
 
(Pain
 
Points)
 
●
 
도구의
 
번잡함:
 
파이참과
 
소스트리를
 
오가는
 
과정의
 
플리커가가
 
흐름을
 
끊음.
 
●
 
시각화의
 
역설:
 
소스트리의
 
시각화된
 
브랜치
 
그래프가
 
오히려
 
현재
 
상태를
 
파악하는
 
데
 
복잡하게
 
느껴져
 
방해가
 
됨.
 
●
 
데이터
 
유실:
 
강의를
 
따라가며
 
Stash
와
 
Branch
를
 
활용했으나,
 
커밋되지
 
않은
 
상태에서
 
조작하다
 
코드가
 
날아가는
 
경험을
 
함.
 
2.
 
깨달은
 
핵심
 
원칙
 
(Safe
 
Workﬂow)
 
"Stash
는
 
믿지
 
마라,
 
오직
 
Commit
만이
 
나를
 
구원한다."
 
●
 
Revert
 
>
 
Stash:
 
임시
 
저장이
 
필요할
 
때도
 
일단
 
커밋을
 
하고,
 
나중에
 
Revert
로
 
되돌리는
 
것이
 
훨씬
 
안전함.
 
기록(
Log)
이
 
남기
 
때문에
 
절대
 
데이터가
 
영구적으로
 
사라지지
 
않음.
 
*저작권
 
주의
 
(주)업스테이지가
 
제공하는
 
모든
 
교육
 
콘텐츠의
 
지식재산권은
 
운영
 
주체인
 
(주)업스테이지에게
 
귀속되어
 
있습니다.
 
콘텐츠
 
일부
 
또는
 
전부를
 
복사,
 
복제,
 
판매,
 
재판매
 
공개,
 
공유
 
등을
 
할
 
수
 
없습니다.
 

 
 
●
 
Conﬂict
는
 
정면
 
돌파:
 
<<<<<<<
,
 
=======
,
 
>>>>>>>
 
기호를
 
직접
 
보고
 
내가
 
원하는
 
코드를
 
남기는
 
과정이
 
가장
 
확실한
 
병합
 
방법임.
 
 
3.
 
나만의
 
미니멀
 
개발
 
셋팅
 
(VS
 
Code
 
All-in-One)
 
여러
 
앱을
 
띄우는
 
대신
 
VS
 
Code
 
하나에
 
강력한
 
확장
 
프로그램을
 
붙여
 
'경량화'
 
성공.
 
●
 
Git
 
Graph:
 
소스트리
 
없이도
 
필요한
 
만큼의
 
그래프만
 
확인.
 
●
 
Thunder
 
Client:
 
포스트맨
 
없이
 
가볍게
 
API
 
테스트.
 
●
 
Terminal
 
(CMD/Git
 
Bash):
 
마우스
 
클릭보다
 
정확한
 
명령어
 
제어.
 
 
4.
 
실습
 
복습:
 
충돌(
Conﬂict)
 
해결
 
시나리오
 
사용자님이
 
직접
 
경험한
 
**"가장
 
매끄럽지
 
않았던
 
그
 
지점"**을
 
공략하는
 
법입니다.
 
1.
 
상황:
 
main
과
 
feature
 
브랜치가
 
같은
 
줄을
 
수정함.
 
2.
 
현상:
 
머지
 
시
 
>>>>>>>
 
기호
 
발생.
 
3.
 
해결
 
전략:
 
○
 
Accept
 
Current:
 
내
 
코드만
 
남기기
 
○
 
Accept
 
Incoming:
 
상대
 
코드만
 
남기기
 
○
 
Accept
 
Both:
 
둘
 
다
 
남기기
 
(위아래
 
순서
 
조정)
 
4.
 
마무리:
 
기호
 
삭제
 
후
 
Save
 
->
 
Add
 
->
 
Commit
.
 
 
 
Day
 
03
 
코랩
 
세션
 
 
*저작권
 
주의
 
(주)업스테이지가
 
제공하는
 
모든
 
교육
 
콘텐츠의
 
지식재산권은
 
운영
 
주체인
 
(주)업스테이지에게
 
귀속되어
 
있습니다.
 
콘텐츠
 
일부
 
또는
 
전부를
 
복사,
 
복제,
 
판매,
 
재판매
 
공개,
 
공유
 
등을
 
할
 
수
 
없습니다.
 

 
 
오늘의
 
실습
 
히스토리
 
(Summary)
 
1단계:
 
로컬
 
파일
 
정리
 
및
 
첫
 
커밋
 
●
 
작업
 
내용:
 
atozwizard
 
폴더
 
내의
 
.txt
 
파일들을
 
backup
 
폴더로
 
옮기고,
 
fork
 
폴더로
 
이동시키는
 
등
 
로컬
 
환경을
 
정리했습니다.
 
●
 
핵심
 
이슈:
 
"커밋을
 
했는데
 
싱크(
Sync)
도
 
눌러야
 
하나?"
 
●
 
해결:
 
**커밋(로컬
 
저장)**과
 
**싱크/푸시(서버
 
전송)**의
 
차이를
 
이해하고,
 
싱크를
 
눌러
 
GitHub
 
서버에
 
반영했습니다.
 
2단계:
 
원격
 
저장소
 
클론(
Clone)
 
및
 
로컬
 
환경
 
구축
 
●
 
작업
 
내용:
 
다른
 
수강생의
 
리포지토리를
 
Fork
한
 
후,
 
VS
 
Code
 
터미널에서
 
git
 
clone
 
명령어를
 
사용하여
 
내
 
컴퓨터로
 
프로젝트
 
전체를
 
내려받았습니다.
 
●
 
핵심
 
이슈:
 
VS
 
Code
 
터미널과
 
GUI
를
 
활용한
 
로컬
 
작업
 
환경
 
세팅.
 
●
 
해결:
 
명령
 
팔레트(
Ctrl+Shift+P
)와
 
터미널을
 
병행하며
 
프로젝트
 
구조를
 
잡았습니다.
 
3단계:
 
브랜치(
Branch)
 
생성
 
및
 
작업
 
분리
 
●
 
작업
 
내용:
 
main
 
브랜치가
 
아닌
 
개인
 
작업용
 
브랜치
 
atozwizard
를
 
생성했습니다.
 
●
 
핵심
 
이슈:
 
git
 
branch
 
명령어로
 
현재
 
내가
 
어느
 
브랜치에
 
있는지
 
확인하는
 
법을
 
익혔습니다.
 
●
 
해결:
 
atozwizard
 
브랜치에서
 
README.md
 
파일을
 
최상위
 
경로(
Root)
에
 
생성하여
 
독립적인
 
작업
 
공간을
 
확보했습니다.
 
4단계:
 
추적(
Add)
과
 
스테이징의
 
이해
 
●
 
작업
 
내용:
 
새로
 
만든
 
파일을
 
커밋하기
 
전
 
단계를
 
수행했습니다.
 
●
 
핵심
 
이슈:
 
"커밋
 
전
 
git
 
add
를
 
왜
 
굳이
 
해야
 
하는가?"
 
●
 
해결:
 
깃이
 
파일을
 
추적하도록
 
만드는
 
'검문소(
Staging
 
Area)'
의
 
개념을
 
이해하고,
 
VS
 
Code
의
 
+
 
버튼으로
 
스테이징
 
후
 
커밋/푸시를
 
완료했습니다.
 
5단계:
 
Pull
 
Request(PR)
와
 
협업
 
프로세스
 
●
 
작업
 
내용:
 
내가
 
수정한
 
내용을
 
원본
 
저장소(상대방의
 
develop
 
브랜치)에
 
합쳐달라고
 
요청했습니다.
 
*저작권
 
주의
 
(주)업스테이지가
 
제공하는
 
모든
 
교육
 
콘텐츠의
 
지식재산권은
 
운영
 
주체인
 
(주)업스테이지에게
 
귀속되어
 
있습니다.
 
콘텐츠
 
일부
 
또는
 
전부를
 
복사,
 
복제,
 
판매,
 
재판매
 
공개,
 
공유
 
등을
 
할
 
수
 
없습니다.
 

 
 
●
 
핵심
 
이슈:
 
"내
 
리포에는
 
파일이
 
있는데
 
왜
 
상대방
 
리포엔
 
안
 
보일까?",
 
"PR
이
 
바로
 
적용된
 
건가?"
 
●
 
해결:
 
*
 
PR
은
 
**'제안'**일
 
뿐이며,
 
상대방이
 
Merge(
병합)
 
버튼을
 
눌러야
 
최종
 
반영된다는
 
점을
 
깨달았습니다.
 
○
 
Open(
초록색
)
과
 
Merged(
보라색
)
 
상태
 
아이콘의
 
차이를
 
통해
 
진행
 
상황을
 
확인했습니다.
 
 
 
Day
 
04
 
코랩
 
세션
 
v
 
기술
 
회고
 
및
 
정리
 
 
1.
 
uv
의
 
정체와
 
핵심
 
가치
 
정의
:
 
Rust
로
 
작성된
 
초고속
 
파이썬
 
패키지
 
및
 
프로젝트
 
관리자입니다
.
 
 
통합
 
관리
:
 
기존의
 
pyenv(
버전
 
관리
),
 
pip(
설치
),
 
venv(
가상환경
),
 
poetry(
의존성
 
관리
)
 
기능을
 
하나로
 
합쳤습니다
.
 
 
압도적
 
속도
:
 
기존
 
도구
 
대비
 
10~100
배
 
빠르며
,
 
캐싱
 
메커니즘을
 
통해
 
중복
 
설치를
 
방지하고
 
디스크
 
용량을
 
효율적으로
 
사용합니다
.
 
 
2.
 
프로젝트
 
시작
 
및
 
VS
 
Code
 
연동
 
 
초기화
:
 
uv
 
init
 
명령어로
 
pyproject.toml
과
 
가상환경
(.
venv)
을
 
동시에
 
생성하며
 
프로젝트를
 
시작했습니다
.
 
 
인터프리터
 
설정
:
 
VS
 
Code
에서
 
Select
 
Interpreter
 
메뉴를
 
통해
 
프로젝트
 
내부의
 
./venv/Scripts/python.exe
를
 
선택하여
 
연동했습니다
.
 
 
자동
 
인식
:
 
폴더
 
내에
 
.venv
가
 
있으면
 
VS
 
Code
가
 
이를
 
자동으로
 
감지하여
 
환경을
 
제안한다는
 
점을
 
확인했습니다
.
 
 
3.
 
주요
 
명령어
 
및
 
활용
 
 
*저작권
 
주의
 
(주)업스테이지가
 
제공하는
 
모든
 
교육
 
콘텐츠의
 
지식재산권은
 
운영
 
주체인
 
(주)업스테이지에게
 
귀속되어
 
있습니다.
 
콘텐츠
 
일부
 
또는
 
전부를
 
복사,
 
복제,
 
판매,
 
재판매
 
공개,
 
공유
 
등을
 
할
 
수
 
없습니다.
 

 
 
패키지
 
추가
:
 
uv
 
add
 
[
패키지명
]
을
 
통해
 
가상환경
 
설치와
 
pyproject.toml
 
기록을
 
한
 
번에
 
처리했습니다
.
 
 
실행
:
 
uv
 
run
 
[
파일명
]
을
 
사용하면
 
가상환경
 
활성화
 
여부와
 
상관없이
 
안전하게
 
코드를
 
실행할
 
수
 
있음을
 
배웠습니다
.
 
 
기존
 
프로젝트
 
전환
:
 
uv
 
add
 
-r
 
requirements.txt
 
명령어로
 
기존의
 
의존성
 
목록을
 
uv
 
체계로
 
빠르게
 
가져오는
 
방법을
 
익혔습니다
.
 
 
4.
 
환경
 
관리
 
및
 
최적화
 
(C
드라이브
 
관리
)
 
 
로컬
 
가상환경
:
 
아나콘다와
 
달리
 
가상환경이
 
프로젝트
 
폴더
 
내부에
 
위치하여
,
 
프로젝트
 
삭제
 
시
 
관련
 
용량도
 
깔끔하게
 
정리되는
 
구조임을
 
이해했습니다
.
 
 
캐시
 
정리
:
 
uv
 
cache
 
clean
 
명령어를
 
통해
 
빌드
 
및
 
다운로드
 
캐시를
 
정리하여
 
C
드라이브
 
용량을
 
확보하는
 
법을
 
확인했습니다
.
 
 
Docker
와의
 
시너지
:
 
uv
를
 
Docker
 
빌드
 
과정에
 
포함하면
 
빌드
 
속도를
 
획기적으로
 
줄일
 
수
 
있으며
,
 
이는
 
곧
 
인프라
 
리소스
 
절약으로
 
이어진다는
 
점을
 
파악했습니다
.
 
 
5.
 
아나콘다
(
Conda)
와의
 
비교
 
 
경량화
:
 
무거운
 
아나콘다
 
시스템
 
전체를
 
유지할
 
필요
 
없이
,
 
프로젝트별로
 
꼭
 
필요한
 
파이썬
 
버전과
 
패키지만
 
가볍게
 
유지할
 
수
 
있다는
 
점이
 
큰
 
장점임을
 
느꼈습니다
.
 
 
재현성
:
 
uv.lock
 
파일을
 
통해
 
협업
 
시
 
팀원
 
모두가
 
동일한
 
환경을
 
100%
 
재현할
 
수
 
있다는
 
점에서
 
현대적인
 
협업
 
방식에
 
더
 
적합함
 
 
Day
 
05
 
코랩
 
세션
 
 
*저작권
 
주의
 
(주)업스테이지가
 
제공하는
 
모든
 
교육
 
콘텐츠의
 
지식재산권은
 
운영
 
주체인
 
(주)업스테이지에게
 
귀속되어
 
있습니다.
 
콘텐츠
 
일부
 
또는
 
전부를
 
복사,
 
복제,
 
판매,
 
재판매
 
공개,
 
공유
 
등을
 
할
 
수
 
없습니다.
 

 
 
●
 
ORM
 
(Object-Relational
 
Mapping):
 
파이썬
 
객체와
 
DB
 
테이블을
 
연결하는
 
기술입니다
.
 
●
 
DB
 
드라이버
:
 
mysql-connector-python
을
 
설치하여
 
파이썬이
 
MySQL
과
 
대화할
 
수
 
있는
 
통로를
 
만들었습니다
.
 
●
 
계정
 
권한
 
문제
:
 
Access
 
denied
 
for
 
user
 
'tester'
 
에러를
 
통해
 
MySQL
 
계정
 
생성
 
및
 
권한
 
부여
(
GRANT
)
의
 
중요성을
 
배웠습니다
.
 
 
 
●
 
Create
 
(POST):
 
사용자의
 
입력을
 
받아
 
INSERT
 
INTO
 
문으로
 
데이터를
 
저장하고
,
 
%s
를
 
사용해
 
보안
(
SQL
 
Injection
 
방지
)
을
 
챙겼습니다
.
 
●
 
Read
 
(GET):
 
SELECT
 
id,
 
content,
 
created_at
 
FROM
 
todo
 
문으로
 
전체
 
목록을
 
불러와
 
리스트
 
형태로
 
반환했습니다
.
 
●
 
Delete
 
(DELETE):
 
WHERE
 
id
 
=
 
%s
 
조건을
 
사용하여
 
특정
 
데이터만
 
안전하게
 
삭제하는
 
법을
 
익혔습니다
.
 
 
 
오늘
 
마주친
 
에러들은
 
개발자라면
 
평생
 
마주칠
 
'
피가
 
되고
 
살이
 
되는
'
 
경험입니다
.
 
에러
 
코드
 
의미
 
해결책
 
404
 
Not
 
Found
 
주소를
 
못
 
찾음
 
URL
 
스펠링
(
todos
)
 
및
 
서버
 
실행
 
확인
 
500
 
Internal
 
Error
 
코드
 
내부
 
오류
 
터미널
 
로그
 
확인
 
후
 
SQL
 
오타
 
및
 
컬럼명
 
수정
 
1045
 
(Access
 
Denied)
 
DB
 
접속
 
거부
 
유저
 
생성
(
tester
)
 
및
 
비번
/
권한
 
설정
 
Git
 
[rejected]
 
로컬
-
원
격
 
불일치
 
pull
 
--rebase
로
 
동기화
 
후
 
다시
 
push
 
 
4.
 
개발
 
환경
 
도구
 
활용
 
*저작권
 
주의
 
(주)업스테이지가
 
제공하는
 
모든
 
교육
 
콘텐츠의
 
지식재산권은
 
운영
 
주체인
 
(주)업스테이지에게
 
귀속되어
 
있습니다.
 
콘텐츠
 
일부
 
또는
 
전부를
 
복사,
 
복제,
 
판매,
 
재판매
 
공개,
 
공유
 
등을
 
할
 
수
 
없습니다.
 

 
 
●
 
Uvicorn:
 
--reload
 
옵션으로
 
코드를
 
수정할
 
때마다
 
서버가
 
자동
 
재시작되도록
 
설정했습니다
.
 
●
 
Thunder
 
Client:
 
Postman
 
대신
 
VS
 
Code
 
내부에서
 
바로
 
API
를
 
테스트하는
 
법을
 
익혔습니다
.
 
●
 
Swagger
 
UI
 
(
/docs
):
 
FastAPI
가
 
자동으로
 
만들어주는
 
문서로
 
브라우저에서
 
직접
 
테스트를
 
수행했습니다
.
 
 
 
*저작권
 
주의
 
(주)업스테이지가
 
제공하는
 
모든
 
교육
 
콘텐츠의
 
지식재산권은
 
운영
 
주체인
 
(주)업스테이지에게
 
귀속되어
 
있습니다.
 
콘텐츠
 
일부
 
또는
 
전부를
 
복사,
 
복제,
 
판매,
 
재판매
 
공개,
 
공유
 
등을
 
할
 
수
 
없습니다.
 

