Lecture 6:
Graph & Search (BFS,DFS)
김수경
이화여자대학교 인공지능융합전공 소속© 2025 Upstage Co., Ltd.
1
2저작권 안내
(주)업스테이지가 제공하는 모든 교육 콘텐츠의 지식재산권은
운영 주체인 (주)업스테이지 또는 해당 저작물의 적법한 관리자에게 귀속되어 있습니다 .
콘텐츠 일부 또는 전부를 복사 , 복제 , 판매 , 재판매 공개 , 공유 등을 할수없습니다 . 
유출될 경우 지식재산권 침해에 대한 책임을 부담할 수있습니다 . 
유출에 해당하여 금지되는 행위의 예시는 다음과 같습니다 . 
● 콘텐츠를 재가공하여 온/오프라인으로 공개하는 행위
● 콘텐츠의 일부 또는 전부를 이용하여 인쇄물을 만드는 행위
● 콘텐츠의 전부 또는 일부를 녹취 또는 녹화하거나 녹취록을 작성하는 행위
● 콘텐츠의 전부 또는 일부를 스크린 캡쳐하거나 카메라로 촬영하는 행위
● 지인을 포함한 제3자에게 콘텐츠의 일부 또는 전부를 공유하는 행위
● 다른 정보와 결합하여 Upstage Education 의콘텐츠임을 알아볼 수있는 저작물을 작성 , 공개하는 행위
● 제공된 데이터의 일부 혹은 전부를 Upstage Education 프로젝트 /실습 수행 이외의 목적으로 사용하는 행위
3Graphs01
Definitions
● Graph G= (V, E), where
○ Vis a set of vertices (nodes), and
○ Eis the set of edges.
● Subgraph : a subset of a graph’s vertices and edges.
● Two vertices are adjacent if they are joined by an edge.
A
B
DC
EA
DC06 Graph & Search (BFS, DFS)
Graph Examples
06 Graph & Search (BFS, DFS)
[1]서울교통공사
[2] Google Map[1] [2] 
Graph Examples
06 Graph & Search (BFS, DFS)
[1] [2] 
[1]https://www.smrfoundation.org/2010/04/28/mapping -the-twitter -network -of-www2010 -with-nodexl/
[2] https://noureldien.com/research/videograph/index.html
Graph Examples
06 Graph & Search (BFS, DFS)
[1] [2] 
[1 https://www.nitrc.org/project/list_screenshots.php?group_id=504&screenshot_id=381
[2] https://www.researchgate.net/figure/Distinction -between -a-Graphical -Model -and-a-CAD -Model_fig1_361770871

Definitions
● Path : A sequence of connected edges 
● Cycle : A path whose starting vertex and ending vertex are the same
● Simple path : A path that contains no cycle
● Simple cycle : A cycle that contains no cycle in it
A
B
DC
EA
B
DC
ESimple pathSimple cycle06 Graph & Search (BFS, DFS)
Definitions
● Connected graph : Each pair of distinct vertices has a path between them
● Complete graph : Each pair of distinct vertices has an edge between them
Connected graph Disconnected graph Complete graph06 Graph & Search (BFS, DFS)
[1] 
[1]https://user.ceng.metu.edu.tr/~tcan/ceng301_s1516/Schedule/week14.pdf
Definitions
● Weighted graph vs. unweighted graph: whether edges have weights
● Directed graph vs. undirected graph: whether edges have direction
Weighted graph Directed graph06 Graph & Search (BFS, DFS)
[1] 
[1]https://user.ceng.metu.edu.tr/~tcan/ceng301_s1516/Schedule/week14.pdf
Definitions
● These are not allowed in (regular) graphs:
○ Multigraph : more than one edges allowed for a same pair of nodes.
○ Self edge : an edge starts from and arrives at the same node.
Multigraph Self edge
06 Graph & Search (BFS, DFS)
[1] 
[1]https://user.ceng.metu.edu.tr/~tcan/ceng301_s1516/Schedule/week14.pdf
Tree vs.Graph?
● Tree is a special case of graph, where
○ all nodes are connected , and
○ there is no cycle .
A
B
DC
EA
B
DC
E
Any node can be the root.06 Graph & Search (BFS, DFS)
Exercise
● Tree vs.Graph?
● Connected vs.disconnected?
● Cyclic vs.acyclic?
● Directed vs.undirected?
Graph
Connected
Cyclic
Directed
06 Graph & Search (BFS, DFS)
[1]서울교통공사[1] 
14Graph Representation02
Adjacency Matrix
● Adjacency matrix
○ A graph is represented by an N×Nmatrix (2D array) , where matrix[i][j] is 1 if there is an edge 
between vertex iand vertex j, and 0 otherwise.
○ In case of a directed graph, matrix[i][j] is 1 if there is an edge from vertex ito vertex j.
○ In case of a weighted graph, matrix[i][j] has the weight value, instead of 1.
● This is analogous to the array -based implementation of other data structures.
○ We use fixed size of memory (corresponding to N×N), regardless of how many edges we have.
○ (+) random access is done at O(1).
○ (-) inefficient use of memory if the graph is sparsely connected.06 Graph & Search (BFS, DFS)
Adjacency Matrix: Example
Directed graph06 Graph & Search (BFS, DFS)
[1] 
[1]https://user.ceng.metu.edu.tr/~tcan/cen g301_s1516/Schedule/week14.pdf
Adjacency Matrix: Example
Weighted undirected graph
06 Graph & Search (BFS, DFS)
[1]https://user.ceng.metu.edu.tr/~tcan/cen g301_s1516/Schedule/week14.pdf[1] 
Adjacency List
● Adjacency list
○ A graph is represented by Nlinked lists where list[i] is the list of vertices that is adjacent to vertex i.
○ In case of weighted graph, the list also contains the weight values.
● This is analogous to the reference -based implementation of other data structures.
○ For each node, we use variable size of memory, depending on the number of edges connected from/to it.
○ (+) efficient use of memory if the graph is sparsely connected.
○ (-) need linear search for an edge. (Not a big problem if the graph is sparse enough.)06 Graph & Search (BFS, DFS)
Adjacency List: Example06 Graph & Search (BFS, DFS)
Directed graph
[1] 
[1]https://user.ceng.metu.edu.tr/~tcan/cen g301_s1516/Schedule/week14.pdf
Adjacency List: Example
Weighted undirected graph06 Graph & Search (BFS, DFS)
[1] 
[1]https://user.ceng.metu.edu.tr/~tcan/cen g301_s1516/Schedule/week14.pdf
Adjacency List: Implementation
class undirected_graph ():
def __init__ (self, nodes, edges):
self.v = nodes[:]
self.e = {}
for node in nodes:
self.e[node] = []
for (u, v) in edges:
self.e[v].append(u)
self.e[u].append(v)
v = ['a', 'b', 'c']
e = [('a', 'b'), ('b', 'c')]
graph = undirected_graph(v, e)
print(graph.e)
{'a': ['b'], 'b': ['a', 'c'], 'c': ['b']}● Can you modify this to
○ directed graph?
○ weighted graph?06 Graph & Search (BFS, DFS)
Google Interview Question
● Design a Graph class.
○ What is the graph for? What data to be stored?
○ How big will be the graph?
○ Is the graph expected to be sparse or dense ?
○ What operations are we going to use most frequently?
○ Is the node & edge likely static or dynamic ?06 Graph & Search (BFS, DFS)
23Graph Traversal03
Graph Traversal
● Goal: Visiting all nodes once in the graph.
○ E.g. , for searching a specific node
○ Caution: graphs may have cycles and may be disconnected . We still should visit all nodes, but should 
not visit the same node more than once, and finish once we visit all of them.
jk06 Graph & Search (BFS, DFS)
[1] 
[1]https://user.ceng.metu.edu.tr/~tcan/cen g301_s1516/Schedule/week14.pdf
Depth First Search (DFS)
● Start from an arbitrary node.
● Visit any connected unvisited node from there.
● If no more node to visit, backtrack to the previous one, and keep going.
jk
This slide is best seen with animations.06 Graph & Search (BFS, DFS)
Depth First Search (DFS)
● To backtrack, we need to trace our footprints!
● What data structure would work best?
○ We backtrack to the most recently visited previous node!
○ Last -in, First -out: Stack would work nicely here!
a
b a b
c a b cNode visited Stack (bottom to top)
d a b c d
g a b c d g
e a b c d g e
(backtrack) a b c d g
f a b c d g f
(backtrack) a b c d g
(backtrack) a b c da
h a b c d h
(backtrack) a b c d
(backtrack) a b c
(backtrack) a b
(backtrack) a
i a i
(backtrack) a
(backtrack) (empty)06 Graph & Search (BFS, DFS)
[1] 
[1]https://user.ceng.metu.edu.tr/~tcan/cen g301_s1516/Schedule/week14.pdf
Depth First Search (DFS)
def dfs(self):
unvisited = self.v.copy()
stack = Stack()
while not unvisited.is_empty():
visit(unvisited[0])  # visit origin
stack.push(unvisited[0])
del unvisited[0]
while not stack.is_empty():
curr = stack.peek()
if there remains an unvisited city from curr:
next = select an unvisited city from curr
visit(next)
stack.push(next)
delete next from unvisited
else:
stack.pop()  # backtrackingDo something when we 
visit the node.
(e.g., print, compare, …)
For each connected node 
fromcurr node (accessed 
by internal adjacency 
matrix or list ), check if it is 
in the unvisited .We need this loop to take care of 
disconnected nodes !06 Graph & Search (BFS, DFS)
Time Complexity of DFS
● At each step,
○ We visit a node x.
○ For the node x, we search the list of adjacent nodes.
○ If there is an unvisited adjacent node, move to there.
○ If not, backtrack to the previously visited node.
● How many such steps?
● In total:O(1)
O(|V|)
O(1)
O(1)With adj. matrix
O(|V|)
O(|V|2)With adj. list
Total number of search
= number of edges (|E|)
O(|V| + |E|)06 Graph & Search (BFS, DFS)
Breadth First Search (BFS)
● Start from an arbitrary node.
● Visit allconnected unvisited node from there.
● In the next step, repeat the same thing on those nodes. Keep going!
This slide is best seen with animations.
jk
1
234
5
6
78
106 Graph & Search (BFS, DFS)
Breadth First Search (BFS)
● We keep track of the order to process: ①, ②, ③, …
● What data structure would work best?
○ We process the waiting nodes in the order of our visit.
○ Fast -in, First -out: Queue would work nicely here!
a
a b f i
b f i c eNode visited Queue (front to back)
f i c e g
i c e g
c e g d
e g d
g d
d h
h (empty)06 Graph & Search (BFS, DFS)
[1] 
[1]https://user.ceng.metu.edu.tr/~tcan/cen g301_s1516/Schedule/week14.pdf
Breadth First Search (BFS)
def bfs(self):
unvisited = self.v.copy()
queue = Queue()
while not unvisited.is_empty():
queue.enqueue(some unvisited node)
while not queue.is_empty():
curr = queue.dequeue()
visit(curr)
delete curr from unvisited
for city in all unvisited cities connected from curr:
queue.enqueue(city)Do something when we visit the node.
(e.g., print, compare, …)
For each connected node 
from curr node (accessed 
by internal adjacency 
matrix or list ), check if it is 
in the unvisited .We need this loop to take care 
of disconnected nodes !06 Graph & Search (BFS, DFS)
DFS vs.BFS
● DFS and BFS visit the nodes in different order.
○ BFS visits nodes closer to the origin first. With an unweighted graph, the path discovered by BFS is a 
shortest path from the origin to that node.
● Following the arrows, we build a tree.
○ Recall that the tree is a special graph, connected without a cycle.
DFS
BFSorigin06 Graph & Search (BFS, DFS)
[1] 
[1]https://user.ceng.metu.edu.tr/~tcan/cen g301_s1516/Schedule/week14.pdf
Time Complexity of BFS
● At each step,
○ Dequeue a node from the queue and visit it (call it x).
○ From the node x, enque all unvisited adjacent nodes.
● How many such steps?
● In total:O(1)
O(|V|)With adj. matrix
O(|V|)
O(|V|2)With adj. list
Total number of search
= number of edges (|E|)
O(|V| + |E|)06 Graph & Search (BFS, DFS)
34Minimum Spanning Trees04
Spanning Trees
● Given an undirected connected graph G, find a tree as a subgraph of Gthat contains all of G’s vertices.
○ Recall that a Tree is a connected graph with no cycles, and it must contain |V| -1edges.
● For unweighted graphs, we may use DFS or BFS:
origin
 origin
DFS 
TreeBFS Tree06 Graph & Search (BFS, DFS)
[1] 
[1]https://user.ceng.metu.edu.tr/~tcan/cen g301_s1516/Schedule/week14.pdf
Minimum Spanning Trees
● What about the graph is weighted ?
○ Each edge is no longer equal; they have different cost !
○ There may be multiple spanning trees.
→ We are interested in building a valid spanning tree with minimal cost .
Cost = 29 Cost = 3545
103
3
3
23
3
5
445
103
3
3
23
3
5
406 Graph & Search (BFS, DFS)
[1] 
[1]https://user.ceng.metu.edu.tr/~tcan/cen g301_s1516/Schedule/week14.pdf
Minimum Spanning Trees
● Main idea : let’s try a greedy approach (choose the option that looks like best at the current moment, not 
worrying about the future.)
○ Start with a given node selected only.
○ At each step, choose a least -cost edge connecting the visited region and the unvisited region .
○ Keep doing this, until all nodes are within the visited region.
● Prim’s algorithm is a rare case that a greedy algorithm guarantees global optimality.
● Starting from different initial node may result in different tree, but the minimum cost is always the same.06 Graph & Search (BFS, DFS)
Minimum Spanning Trees: Illustration
Cost = 2745
103
3
3
23
3
5
406 Graph & Search (BFS, DFS)06 Graph & Search (BFS, DFS)
[1] 
[1]https://user.ceng.metu.edu.tr/~tcan/cen g301_s1516/Schedule/week14.pdf
Minimum Spanning Trees: Prim’s Algorithm
def prims_mst (graph, start):
visited = [start]
unvisited = graph.nodes.copy().remove(start)
mst = []
while not unvisited.is_empty():
e = least -cost edge from visited to unvisited
u = the node consisting of e from the unvisited side
visited.append(u)
unvisited.remove(u)
mst.append(e)
Time complexity? O(|V| • (|V|+|E|))
Note that this can be further improved by using Priority queue. 
This is beyond the scope of this course.06 Graph & Search (BFS, DFS)
40Topological Sorting05
Topological Sorting
● On a directed graph without cycles, list the nodes in “topological order”:
○ An order of vertices in which vertex xprecedes vertex yif there is an edge from xto y.
○ Usually, there are multiple topological orders for a directed graph.
06 Graph & Search (BFS, DFS)
[1] 
[1]https://user.ceng.metu.edu.tr/~tcan/cen g301_s1516/Schedule/week14.pdf[1] 
Examples
06 Graph & Search (BFS, DFS)
[1] 
[1]https://harshpopculture.wordpress.com/2013/09/02/civilization -v-not-all-sequels -are-as-bad -as-duke -nukem -forever/
Topological Sorting
● Main idea : We should put a node without successors at the end of the output!
○ Choose a node without successors, put it at the end of the current list.
○ Detach the chosen node and all edges to it.
○ Recursively solve with the remaining graph, until no node remains.
● As we delete all edges to already chosen nodes, the next highest ones will become available to choose.06 Graph & Search (BFS, DFS)
Topological Sorting: Illustration
06 Graph & Search (BFS, DFS)
[1] 
[1]https://user.ceng.metu.edu.tr/~tcan/cen g301_s1516/Schedule/week14.pdf[1] 
Topological Sorting: Implementation
def topological_sort (nodes, edges):
output = []
curr_last = Set of all nodes with no incoming edge
while curr_last is not empty:
target = curr_last[0]
output.append(target)
del curr_last[0]
for each node m with an incoming edge e from target:
Remove e from the graph
if m has no other incoming edges:
curr_last.append(m)
if len(output) < len(nodes):
return error  # graph has at least one cycle
else:
return output
Time complexity? O(|V|+ |E|)O(|E|)
Up to |E| times!
Each edge can be removed up to once.Up to |V| times!
Each node can be selected up to once.
At this point, we have no more 
nodes at the last. If there is no 
cycle, we should be done now.06 Graph & Search (BFS, DFS)
www.upstage.ai © 2025 Upstage Co., Ltd.

