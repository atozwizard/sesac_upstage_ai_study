# Day 2. 스택으로 문제 해결하기 – 데일리 미션 (Valid Parentheses)

이 노트북은 **스택(Stack)** 을 활용해 LeetCode **#20 Valid Parentheses** 문제를 푸는 데일리 미션용입니다.

## 🎯 학습 목표
- 스택의 **LIFO(Last-In, First-Out)** 구조와 `push`/`pop` 연산을 이해한다.
- 문자열 속 괄호 패턴을 **스택으로 검증하는 알고리즘**을 설계하고 구현한다.
- 시간복잡도 `O(N)` 알고리즘을 직접 작성하고 분석한다.

---
## 문제: LeetCode #20 — Valid Parentheses

문자열 `s` 가 주어졌을 때, 문자열이 **올바른 괄호 구성(valid parentheses)** 인지 판별하는 함수를 작성하세요.

문자열 `s` 는 `'(', ')', '{', '}', '[', ']'` 문자로만 이루어져 있습니다.

올바른 괄호의 조건은 다음과 같습니다.
1. 열린 괄호는 **반드시 동일한 종류의 닫힌 괄호**로 닫혀야 한다.
2. 열린 괄호는 **올바른 순서**로 닫혀야 한다.
3. 모든 괄호는 **짝이 맞아야 한다.**

### 예시
1. `s = "()"` → `True`
2. `s = "()[]{}"` → `True`
3. `s = "(]"` → `False`
4. `s = "([)]"` → `False`
5. `s = "{[]}"` → `True`

### 제한 조건
- `1 <= s.length <= 10**4`
- `s` 는 `'()[]{}'` 만을 포함합니다.

---
아래 **Step 1 → Step 4** 순서로 미션을 수행해 주세요.

## 🛠️ Prerequisites
본 미션은 Python 표준 기능을 활용하며, 별도의 라이브러리 설치가 필요하지 않습니다.
* **Stack 구현**: Python의 기본 `list`를 활용하여 `push`(append) 및 `pop` 연산을 수행합니다.
* **데이터 구조**: `dict`를 활용해 괄호 쌍을 매핑하여 코드의 가독성을 높입니다.

## Step 1. 문제 이해 & 기본 테스트 케이스 정리

아래 마크다운 셀에 본인이 이해한 문제를 **자신의 말로 정리**해 보세요.

- 어떤 입력이 들어오는가?
- 어떤 출력을 만들어야 하는가?
- 어떤 경우에 `True`, 어떤 경우에 `False` 가 되는가?

또한, 떠오르는 **추가 테스트 케이스**(엣지 케이스 포함)를 2~3개 적어보세요.

### ✏️ 내가 이해한 문제 설명 (학생 작성)

- 문제 요약:주어진 문자열의 괄호가 동일한 종류의 올바른순서로 짝이 맞게 닫혀있느냐를 판별하는 함수 작성
- 입력 형태:string
- 출력 형태:bool
- `True` 가 되는 조건:올바른 괄호구성,순서,종류,짝이 맞다
- `False` 가 되는 조건: 무언가 하나라도 아니다

### ✏️ 추가 테스트 케이스 아이디어
- 예) `"(((("`, `""`, `"([]"`, `"[{()}]"` 등
- 내가 생각한 테스트:

"(3+4)*(2+5)" is well-formed

"((2*2)*3+1)" is not well-formed

")(2+2" is not well-formed

what if we have more than one types of parentheses?

"{(2+1)*(3+2)-22}*7" is well-formed

"{(7+2}*3)" is not well-formed

---
## Step 2. 스택 기반 알고리즘 설계

스택을 활용해 올바른 괄호를 판단하는 알고리즘을 설계해봅시다.

### 아이디어 힌트
- 문자열을 **왼쪽에서 오른쪽으로 한 글자씩** 순회합니다.
- 열린 괄호 `'(' , '{' , '['` 가 나오면 **스택에 push** 합니다.
- 닫힌 괄호가 나오면, 스택에서 하나 꺼내(pop) **짝이 맞는지 확인**합니다.
  - 스택이 비어 있다면? → 잘못된 문자열입니다.
  - 스택 top과 짝이 맞지 않는다면? → 잘못된 문자열입니다.
- 문자열을 모두 확인한 후 **스택이 비어 있으면** 올바른 괄호 문자열입니다.

아래 셀에 본인의 알고리즘을 **자연어/의사코드(pseudocode)** 로 먼저 적어보세요.

### ✏️ 알고리즘 설계 (학생 작성)

1.문자열을 왼쪽에서 오른쪽으로 한글자씩 순회

2.if 열린 괄호 "(", "{" ,"[" 이 나오면:  스택에 push (append)

3.if 닫힌 괄호가 나오면, 스택 탑에서 하나 꺼내 pop 짝이 맞는지 확인

4.if 스택이 비어있다: 잘못된 문자열 False

if 스택에서 꺼낸 top과 짝이 맞지 않는다 : 잘못된 문자열 False

5.문자열을 모두 확인(스택을 다 꺼내고) 비어있으면 올바른 문자열 : True

※ 이 단계에서 충분히 설계해두면, 코드 구현이 훨씬 쉬워집니다.

---
## Step 3. Python 코드 구현

이제 설계한 알고리즘을 실제 코드로 옮겨 봅시다.

가능하면 **다음 조건을 만족하는 코드**를 작성해 보세요.
- Python 리스트를 스택처럼 사용 (`append`, `pop`)
- 괄호 짝 매칭은 `dict` 를 사용하면 더 깔끔합니다. 예: `pairs = {')':'(', ']':'[', '}':'{'}`
- 시간복잡도는 `O(N)` 이어야 합니다.

아래 템플릿을 참고해 `isValid` 메서드를 완성하세요.

"""주어진 문자열 s가 올바른 괄호 문자열인지 판별합니다.

        알고리즘 아이디어:
            TODO: 여기서 스택을 어떻게 사용할지 간단히 설명해 보세요.

            1.문자열을 왼쪽에서 오른쪽으로 한글자씩 순회
            2.if 열린 괄호 "(", "{" ,"[" 이 나오면 스택에 push append
            3.if 닫힌 괄호가 나오면, 스택에서 하나 꺼내 pop 짝이 맞는지 확인
            4.if 스택이 비어있다: 잘못된 문자열 False
              if 스택에서 꺼낸 top과 짝이 맞지 않는다 : 잘못된 문자열 False
              짝은 { ")" : "(" , "}" : "{", "]" : "[" }
            5.문자열을 모두 확인(스택을 다 꺼내고) 비어있으면 올바른 문자열 : True

        시간복잡도:
            TODO: 왜 이 알고리즘의 시간복잡도가 O(N)인지 설명해 보세요.
            1번 순회하는 동안 입력된 N개의 문자열을 하나씩 검증하므로 N만큼 걸린다
        """




class Solution:
    def isValid(self, s: str) -> bool:

        # TODO: 여기에 스택 기반 알고리즘을 구현하세요.

        stack = [] #괄호 쌓을 리스트
        pair = { ")" : "(" , "}" : "{", "]" : "[" }  #짝맞출 딕셔너리

        for x in s:   #s를 하나씩 순회해
            
            if x in pair:       #   - 닫힌 괄호일 때 pair안에 있으면
                    
                if not stack:    #   - 스택이 비어있는 경우 False
                    return False  #pop하기 전에 비어있는지 먼저 확인해야한다

                top = stack.pop()     #stack에 쌓은 마지막것을 꺼내, top이라 하자
                if top != pair[x]:  #꺼낸 top이, pair의 짝과 안맞으면
                    return False  #False
                    
            else: #   - 닫힌 괄호가 아닐 때
                if x in "({[":
                    stack.append(x) #  stack에 append 쌓아놔

            #   - 반복이 끝난 뒤 스택이 비어 있는지 확인
        return len(stack) == 0

        raise NotImplementedError


class Solution:
    def isValid(self, s: str) -> bool:
        stack = []
        pair = {")": "(", "}": "{", "]": "["}
        opens = "({["  # 열린 괄호 정의

        for x in s:
            # 1. 닫힌 괄호인 경우
            if x in pair:
                if not stack:
                    return False
                top = stack.pop()
                if top != pair[x]:
                    return False
            
            # 2. 열린 괄호인 경우에만 스택에 넣기 (수정된 부분)
            elif x in opens:
                stack.append(x)
            
            # 3. 그 외 숫자나 연산자 등은 그냥 무시하고 지나감
            else:
                continue

        return len(stack) == 0

### ✅ 테스트 코드
아래 셀을 실행해서 다양한 입력에 대해 `isValid` 가 올바르게 동작하는지 확인해 보세요.
필요하다면 테스트 케이스를 더 추가해도 좋습니다.

def run_tests():
    sol = Solution()
    tests = [
        ("()", True),
        ("()[]{}", True),
        ("(]", False),
        ("([)]", False),
        ("{[]}", True),
        ("(3+4)*(2+5)",True),
        ("((2*2)*3+1)",True),
        (")(2+2)",False),
        ("{(2+1)*(3+2)-22}*7",True),
        ("{(7+2}*3)",False)
    ]

    for s, expected in tests:
        result = sol.isValid(s)
        print(f"s='{s}' → result={result}, expected={expected}")

run_tests()


---
## Step 4. 시간복잡도 분석 & 정리

아래에 본인의 코드에 대한 **시간복잡도/공간복잡도 분석**과 함께,
스택이 없었다면 어떤 방식으로 풀 수 있을지(그리고 왜 비효율적인지)를 간단히 적어보세요.

### ✏️ 정리 (학생 작성)

- 시간복잡도 분석:
  - O(N) , 주어진 문자열 N개 만큼 1회 순회
- 공간복잡도 분석:
  - o(N) , 주어진 문자열 N개들의 괄호를 별도로 쌓아서 1회 비교하므로
- 이 문제에서 스택이 왜 잘 맞는 도구인지:
  - 괄호의 특징. 열리면 닫아야 하는 특징 때문에, 가장 마지막에 쌓은 것을 비교해야 하므로
  - 후입선출 LIFO 방식에 어울린다
- 스택을 사용하지 않는다면 어떤 방식이 있을지, 그리고 단점은?
  - 큐는 먼저 넣은것이 먼저 나오므로 짝이 맞지 않음.
  - 해시테이블인 딕셔너리는 개수나 위치를 찾을 때는 유리하지만 순서를 기억해야하는 이 경우에 활용하기 어려울 것 같다.각 괄호가 몇 번째 자리에 있는지를 기억하는 인덱스를 저장하는 방식을 써야 한다. 공간복잡도가 커진다.

---
## 제출 전 체크리스트 ✅
- [ ] 스택(list)을 사용해 구현했다.
- [ ] 스택이 비어 있는 상태에서 `pop` 하지 않도록 예외 처리를 했다.
- [ ] 예제 테스트 케이스가 모두 기대한 값으로 나온다.
- [ ] 시간복잡도 `O(N)` 분석을 코드/마크다운에 적었다.
- [ ] 노트북 상단부터 하단까지 실행이 끊김 없이 잘 동작한다.

수고 많았어요! 🎉 Day 2의 기본 스택 패턴은 이후 수많은 문제의 기본기가 됩니다.

###**콘텐츠 라이선스**
<font color='red'><b>**(주)업스테이지가 제공하는 모든 교육 콘텐츠의 지식재산권은
운영 주체인 (주)업스테이지 또는 해당 저작물의 적법한 관리자에게 귀속되어 있습니다.**</b></font>

콘텐츠 일부 또는 전부를 **복사, 복제, 판매, 재판매 공개, 공유** 등을 할 수 없습니다. 유출될 경우 지식재산권 침해에 대한 책임을 부담할 수 있습니다.

유출에 해당하여 금지되는 행위의 예시는 다음과 같습니다.
* 콘텐츠를 재가공하여 온/오프라인으로 공개하는 행위
* 콘텐츠의 일부 또는 전부를 이용하여 인쇄물을 만드는 행위
* 콘텐츠의 전부 또는 일부를 녹취 또는 녹화하거나 녹취록을 작성하는 행위
* 콘텐츠의 전부 또는 일부를 스크린 캡쳐하거나 카메라로 촬영하는 행위
* 지인을 포함한 제3자에게 콘텐츠의 일부 또는 전부를 공유하는 행위
* 다른 정보와 결합하여 Upstage Education의 콘텐츠임을 알아볼 수 있는 저작물을 작성, 공개하는 행위
* 제공된 데이터의 일부 혹은 전부를 Upstage Education 프로젝트/실습 수행 이외의 목적으로 사용하는 행위

class Solution:
    def isValid(self, s: str) -> bool:
        """주어진 문자열 s가 올바른 괄호 문자열인지 판별합니다.

        알고리즘 아이디어:
            TODO: 여기서 스택을 어떻게 사용할지 간단히 설명해 보세요.

        시간복잡도:
            TODO: 왜 이 알고리즘의 시간복잡도가 O(N)인지 설명해 보세요.
        """
        # TODO: 여기에 스택 기반 알고리즘을 구현하세요.
        #   - 열린 괄호일 때의 처리
        #   - 닫힌 괄호일 때의 처리
        #   - 스택이 비어있는 경우 예외 처리
        #   - 반복이 끝난 뒤 스택이 비어 있는지 확인

        q = []
        input_count = 0

        for char in s:
            if ord(char) == 40 or ord(char) == 91 or ord(char) == 123:
              q.append(char)
              input_count += 1
              continue

            if(len(q) <= 0):
              return False

            pop = ord(q.pop())
            pop = pop // 10

            if(pop != ord(char) // 10):
                return False

        if(len(q) == 0 and len(s)/2 == input_count):
          return True
        else:
          return False

        raise NotImplementedError


def run_tests():
    sol = Solution()
    tests = [
        ("()", True),
        ("()[]{}", True),
        ("(]", False),
        ("([)]", False),
        ("{[]}", True),
        ("})]}", False),
        ("([)]", False)
    ]

    for s, expected in tests:
        result = sol.isValid(s)
        print(f"s='{s}' → result={result}, expected={expected}")

run_tests()
