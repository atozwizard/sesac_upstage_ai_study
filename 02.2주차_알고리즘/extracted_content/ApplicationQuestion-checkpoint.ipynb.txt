02
    1.middle of a given linked list
    #중간값 찾기
    #투 포인터, slow pointer 한번에 한칸씩 이동, fast pointer 한번에 두칸씩 이동
    #fast pointer가 리스트의 끝(none)에 도달 했을 때, slow pointer는 정확히 리스트의 중간에 위치.     

        class Node():
            def __init__(self, val = 0, next = None): """val은 value데이터=0 인것은 노드를 생성할 때 실수로 데이터를 넣지 않더라도,
                                                        프로그램이 멈추지 않고 숫자 0을 기본 데이터로 가지게 한다. 주로 숫자데이터를 다룰 것이라는 점도 암시.
                                                        next=None은 이 노드가 기차의 마지막 칸임을 나타내는 중요한 신호.
                                                        처음 생성된 노드는 어디에도 연결되어있지 않으므로 아무것도 가리키지 않는 다는 뜻의 None이
                                                        가장 적절한 초기값이다."""
                self.val = val
                self.next = next
                
            def findmiddle(head:Node) -> Node:
                slow = head
                fast = head  #0이 아닌 head로 객체지정하는 것은 LinkedList 의 특성때문.
                            """노드(데이터)들이 메모리 여기저기에 흩어져 있다. 
                            각 노드는 오직 자신이 가진 next포인터를 통해서만 다음 노드가 어디있는지 알수 있다.
                            따라서, 컴퓨터는 0의 위치로 가달라고 하면 알아듣지 못함. 대신
                            기차의 맨 앞칸(head)주소를 줄테니 여기서부터 시작해 라고 알려줘야 함
                            head는 첫번째 노드 객체 그 자체. slow=0 이라 한다면 노드가 아니라 숫자0 이 됨.
                            숫자 0에는 .next라는 속성이 없기 때문에 에러"""
                
                while fast and fast.next:
                    slow = slow.next        #1칸이동
                    fast = fast.next.next   #2칸이동
                
                return slow  #slow가 가리키는 곳이 중간값

2.reverse a given linked list
    #세 개의 포인터
    """링크드리스트를 뒤집으려면 현재 노드뿐만 아니라, 이전 노드와
    다음 노드의 정보가 동시에 필요함, 이전 현재 다음 포인터.prev, curr, next_node"""
    # 기차 칸들의 연결고리를 하나씩 끊어서 반대방향으로 다시 잇는 작업

        class Node():
            def __init__(self, val=0, next=None):
                self.val = val
                self.next = next
                
            def reverselist(head:Node) -> Node:
                prev = None
                curr = head
                
                while curr:
                    next_node = curr.next """현재 노드의 다음노드 위치를 next_node라는 변수에 잠시 저장
                                            바로 다음 줄에서 현재노드의 다음을 이전 노드로 바꾸면, 다음 칸 포인터를 잃어버림"""
                    curr.next = prev #현재노드 다음을 뒤로 돌림
                    
                    prev = curr #현재노드가 이전노드가 됨
                    curr = next_node #다음 칸으로 넘어가서 다음 작업을 준비
                    
                return prev

 3.detect cycle,circular linked
    #언젠가는 만난다, 투 포인터. 순환한다면 fast pointer는 한 바퀴를 앞질러 slow pointer를 따라잡아 만나게 된다.
    

        class Node():
            def __init__(self, val=0, next=None):
                self.val = val
                self.next = next
                
            def cycle(head: Node) -> bool:
                if not head or not head.next:  """not head: 연결 리스트에 노드가 하나도 없는상태. 
                                                비교할 대상 자체가 없으므로 당연히 순환이 없다.
                                                not head.next: 첫칸 다음이없다, 노드가 하나뿐인 상태.
                                                자기 자신에게 다시 돌아오는 특수한 경우가 아니라면, 노드가 하나일때는
                                                순환이 만들어지지 않는다
                                                이런 상황들을 미리 걸러내는 예외처리 Guard Clause"""
                    return False
                
                slow = head  #출발선 정렬
                fast = head
                
                while fast and fast.next:
                    slow = slow.next #1칸이동
                    fast = fast.next.next #2칸이동
                    
                    if slow == fast: #둘이 만나면, 사이클 있다!
                        return True
                
                return False #fast가 끝에 도달하면 사이클 없음

03 괄호 balance
    use stack to check if a string with parantheses is well-formed
    "(3+4)*(2+5)" is well-formed
    "((2*2)*3+1)" is not well-formed
    ")(2+2" is not well-formed
    what if we have more than one types of parentheses?
    "{(2+1)*(3+2)-22}*7" is well-formed
    "{(7+2}*3)" is not well-formed

class Solution:
            def isValid(self, s: str) -> bool:

                # TODO: 여기에 스택 기반 알고리즘을 구현하세요.

                stack = [] #괄호 쌓을 리스트
                pair = { ")" : "(" , "}" : "{", "]" : "[" }  #짝맞출 딕셔너리

                for x in s:   #s를 하나씩 순회해
                    
                    if x in pair:       #   - 닫힌 괄호일 때 pair안에 있으면
                            
                        if not stack:    #   - 스택이 비어있는 경우 False
                            return False  #pop하기 전에 비어있는지 먼저 확인해야한다

                        top = stack.pop()     #stack에 쌓은 마지막것을 꺼내, top이라 하자
                        if top != pair[x]:  #꺼낸 top이, pair의 짝과 안맞으면
                            return False  #False
                            
                    else: #   - 닫힌 괄호가 아닐 때
                        if x in "({[":
                            stack.append(x) #  stack에 append 쌓아놔

                    #   - 반복이 끝난 뒤 스택이 비어 있는지 확인
                return len(stack) == 0

            raise NotImplementedError


