Lecture 1: 
Basic of Algorithm & 
Computational Complexity 
ê¹€ìˆ˜ê²½ 
ì´í™”ì—¬ìëŒ€í•™êµ ì¸ê³µì§€ëŠ¥ìœµí•©ì „ê³µ ì†Œì† Â© 2025 Upstage Co., Ltd. 
2 ì €ì‘ê¶Œ ì•ˆë‚´ 
 
(ì£¼)ì—…ìŠ¤í…Œì´ì§€ê°€ ì œê³µí•˜ëŠ” ëª¨ë“  êµìœ¡ ì½˜í…ì¸ ì˜ ì§€ì‹ì¬ì‚°ê¶Œì€ 
ìš´ì˜ ì£¼ì²´ì¸ (ì£¼)ì—…ìŠ¤í…Œì´ì§€ ë˜ëŠ” í•´ë‹¹ ì €ì‘ë¬¼ì˜ ì ë²•í•œ ê´€ë¦¬ìì—ê²Œ ê·€ì†ë˜ì–´ ìˆìŠµë‹ˆë‹¤. 
ì½˜í…ì¸  ì¼ë¶€ ë˜ëŠ” ì „ë¶€ë¥¼ ë³µì‚¬, ë³µì œ, íŒë§¤, ì¬íŒë§¤ ê³µê°œ, ê³µìœ  ë“±ì„ í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. 
ìœ ì¶œë  ê²½ìš° ì§€ì‹ì¬ì‚°ê¶Œ ì¹¨í•´ì— ëŒ€í•œ ì±…ì„ì„ ë¶€ë‹´í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. 
ìœ ì¶œì— í•´ë‹¹í•˜ì—¬ ê¸ˆì§€ë˜ëŠ” í–‰ìœ„ì˜ ì˜ˆì‹œëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤. 
â— ì½˜í…ì¸ ë¥¼ ì¬ê°€ê³µí•˜ì—¬ ì˜¨/ì˜¤í”„ë¼ì¸ìœ¼ë¡œ ê³µê°œí•˜ëŠ” í–‰ìœ„ 
â— ì½˜í…ì¸ ì˜ ì¼ë¶€ ë˜ëŠ” ì „ë¶€ë¥¼ ì´ìš©í•˜ì—¬ ì¸ì‡„ë¬¼ì„ ë§Œë“œëŠ” í–‰ìœ„ 
â— ì½˜í…ì¸ ì˜ ì „ë¶€ ë˜ëŠ” ì¼ë¶€ë¥¼ ë…¹ì·¨ ë˜ëŠ” ë…¹í™”í•˜ê±°ë‚˜ ë…¹ì·¨ë¡ì„ ì‘ì„±í•˜ëŠ” í–‰ìœ„ 
â— ì½˜í…ì¸ ì˜ ì „ë¶€ ë˜ëŠ” ì¼ë¶€ë¥¼ ìŠ¤í¬ë¦° ìº¡ì³í•˜ê±°ë‚˜ ì¹´ë©”ë¼ë¡œ ì´¬ì˜í•˜ëŠ” í–‰ìœ„ 
â— ì§€ì¸ì„ í¬í•¨í•œ ì œ3ìì—ê²Œ ì½˜í…ì¸ ì˜ ì¼ë¶€ ë˜ëŠ” ì „ë¶€ë¥¼ ê³µìœ í•˜ëŠ” í–‰ìœ„ 
â— ë‹¤ë¥¸ ì •ë³´ì™€ ê²°í•©í•˜ì—¬ Upstage Educationì˜ ì½˜í…ì¸ ì„ì„ ì•Œì•„ë³¼ ìˆ˜ ìˆëŠ” ì €ì‘ë¬¼ì„ ì‘ì„±, ê³µê°œí•˜ëŠ” í–‰ìœ„ 
â— ì œê³µëœ ë°ì´í„°ì˜ ì¼ë¶€ í˜¹ì€ ì „ë¶€ë¥¼ Upstage Education í”„ë¡œì íŠ¸/ì‹¤ìŠµ ìˆ˜í–‰ ì´ì™¸ì˜ ëª©ì ìœ¼ë¡œ ì‚¬ìš©í•˜ëŠ” í–‰ìœ„ 
3 ê°•ì‚¬ ì†Œê°œ 
ê¹€ìˆ˜ê²½ 
ç¾ ì´í™”ì—¬ìëŒ€í•™êµ  ì¸ê³µì§€ëŠ¥ìœµí•©ì „ê³µ  ì†Œì† ì¡°êµìˆ˜ 
ê´€ì‹¬ ì—°êµ¬ ë¶„ì•¼
-Explainable AI (XAI) 
-NLP and Medical AI 
-AI for Science 
-RL based Optimization 

4 Algorithms & Complexity 
01
5 What is Algorithm? 01 Basic of Algorithm & Computational Complexity 
â— Computational procedure  to solve a problem 
[1] https://blog.naver.com/sumr2002/220359932991 
[2] http://jokesandfun.de/infographic/the-cake-is-a-factï¬‚owchart/ 
[1] [2] 
6 Eï¬ƒciency of an Algorithm 01 Basic of Algorithm & Computational Complexity 
Do you like fast/eï¬ƒcient computer program, or slow one? 
Of course, we always expect our computers to do their jobs most eï¬ƒciently !
[1] https://www.vecteezy.com/photo/20621853-stressed-and-overworked-businessman 
[2] https://stock.adobe.com/search?k=smashed+computer&asset_id=52541504 
[3] https://www.istockphoto.com/kr/%EC%82%AC%EC%A7%84/%EC%97%AC%EC%9E%90-%EC%BB%B4%ED%93%A8%ED%84%B0-gm118986833-12293508 
[2] [1] [3] 
7 Computation Complexity 01 Basic of Algorithm & Computational Complexity 
â— Cost of algorithm = Sum of operation costs 
â— Model of computation speciï¬es 
â—‹ What operations  an algorithm is allowed to use 
â—‹ Cost (time, space) of each operation 
â— Execution costs 
â—‹ Time complexity of a program: how much time ?
â—‹ Space complexity of a program: how much memory ?
8 Measuring Time Complexity 01 Basic of Algorithm & Computational Complexity 
â— Measure execution time  in seconds using a client program ( e.g., time module) 
â—‹ (+) Easy to measure 
â—‹ (+) Gives actual time 
â—‹ (-) Large amounts of time might be required. 
â—‹ (-) Results depend on lots of factors (machine, compiler, dataâ€¦) 
â— Count the number of operations in terms of input size  N
â—‹ (+) Machine independent. 
â—‹ (+) Gives algorithmâ€™s scalability. 
â—‹ (-) Tedious to computeâ€¦ 
â—‹ (-) Does not give actual time. 
â— Fortunately, we care only about asymptotic behavior (with a very large N â€’ Big Data!) 
9 Elementary School Algorithm 01 Basic of Algorithm & Computational Complexity 
Example: Integer multiplication 
â— Input: two N-digit numbers x, y
â— Output: product of x and y
â— Primitive operations allowed: 
â—‹ Add 2 single-digit numbers 
â—‹ Multiply 2 single-digit numbers 
5678 
Ã—1234 
23
13
72
22
17034 
11356 
5678 
7006652 
10 Elementary School Algorithm 01 Basic of Algorithm & Computational Complexity 
Example: Integer multiplication 
â— Input: two N-digit numbers x, y
â— Output: product of x and y
â— Primitive operations allowed: 
â—‹ Add 2 single-digit numbers 
â—‹ Multiply 2 single-digit numbers 5678 
Ã—1234 
23
13
72
22
17034 
11356 
5678 
7006652 N multiplications 
(up to) N-1 additions For each row: 
N rows 
Total operations â‰¤ 3 N2In total, 
N(2N-1 ) operations 
(up to) N2 additions How many primitive operations used? 
11 Software Engineerâ€™s Example 01 Basic of Algorithm & Computational Complexity 
def linear_search (list, value): 
  for i in range(len(list)): 
    if list[i] == value: 
      return i 
  return -1 
def selection_sort (list): 
  for i in range(len(list)): 
    smallest = i 
    for j in range(i+1, len(list)): 
      if list[j] < list[smallest]: 
        smallest = j 
    list[i], list[smallest] = list[smallest], 
list[i] Letâ€™s denote len(list)  as N:
Operation Count 
== Operation Count 
smallest = i 
< 
smallest = j 
swap 1 to N N
(N2 - N)/2 
0 to (N2 - N)/2 
N
12 Big O Notation 
02
How to Characterize Time Complexity more formally  and simply ?
13 Simpliï¬cation of Time Complexity 01 Basic of Algorithm & Computational Complexity 
1. We care only about the worst-case  performance! 
 â† because we do not know what input data we will get in advance. 
Operation Count 
smallest = i N
< (N2 - N)/2 
smallest = j 0 to (N2 - N)/2 
swap N
14 Simpliï¬cation of Time Complexity 01 Basic of Algorithm & Computational Complexity 
2. Focus only on a single operation with the  highest order  of growth (=most expensive). 
â— There may be multiple good choices. Then, just choose any of them. 
Operation Count 
smallest = i N
< (N2 - N)/2 
smallest = j (N2 - N)/2 
swap N
15 Simpliï¬cation of Time Complexity 01 Basic of Algorithm & Computational Complexity 
3. Remove lower order terms. 
â† They do not really matter, since the higher order one dominates. 
Operation Count 
smallest = i ignored 
< ignored 
smallest = j (N2 - N)/2 
swap ignored 
16 Simpliï¬cation of Time Complexity 01 Basic of Algorithm & Computational Complexity 
4. Remove constants. 
â† We have already thrown away information at step 2. At this stage, constants are not meaningful. 
Operation Count 
smallest = i ignored 
< ignored 
smallest = j (N2)/2
swap ignored Worst-case order of growth : N2
17 Formal Deï¬nition 01 Basic of Algorithm & Computational Complexity 
â— If a function T (N) has its order of growth  less than or equal to f (N), we write this as T (N) âˆˆ O( f (N)), where O is 
called Big-O notation. 
â— More mathematically, T (N) âˆˆ O( f (N)) means that there exists a positive constant c such that T (N)  â‰¤ c f (N) for all 
values of N greater than some positive N0 (i.e., large N).

18 Example 01 Basic of Algorithm & Computational Complexity 
â— T (N) = N 2 + 5N 5
â— T (N) âˆˆ O(N 5)?
â—‹ That is, is there a positive constant c such that N 2 + 5N 5  â‰¤ cN 5 for large N?
â—‹ Yes! 
â–  N 2 + 5N 5 < N 5 + 5N 5 = 6N 5
â–  With c = 6, it holds. 
â— T (N) âˆˆ O( N 7)?
â—‹ That is, is there a positive constant c such that N 2 + 5N 5  â‰¤ cN 7 for large N?
â—‹ Yes! 
â–  N 2 + 5N 5 < N 5 + 5N 5 = 6N 5 < 6N 7 
â–  With c = 6, it holds. 

19 Example(contâ€™d) 01 Basic of Algorithm & Computational Complexity 
â— T (N) = N 2 + 5N 5
â— T (N) âˆˆ O(N 4)?
â—‹ That is, is there a positive constant c such that N 2 + 5N 5  â‰¤ cN 4 for large N?
â—‹ No ğŸ˜•
â–  Even if we set very large c, still for N > c, 5N 5 > N 5 > cN 4.
â— We are usually interested in the tightest  order; in this example, O( N 5).

20 Exercise(contâ€™d) 01 Basic of Algorithm & Computational Complexity 
â— T(N) = 2 N2 + 3N
â— T(N) = 1/ N + 100 
â— T(N) = 100cos( N) + 50 N2
â— T(N) = log N + 2N
â— T(N) = 2N + N2
O(N2)
O(1) 
O(N2)
O(N)
O(2N)
21 What is Important for Asymptotic Analysis? 01 Basic of Algorithm & Computational Complexity 
â— Compare the two algorithms below: 
â—‹ Algo1 requires 2N 2 operations, while 
â—‹ Algo2 requires 500 N operations. 
â—‹ Algo1 is faster than Algo2 for a small N, but becomes much slower for a very large N.
â—‹ What is important? How fast function is growing !
â— Order of growth: 
500 N
2N 2
22 Asymptotic Analysis 01 Basic of Algorithm & Computational Complexity 

www.upstage.ai Â© 2025 Upstage Co., Ltd. 

