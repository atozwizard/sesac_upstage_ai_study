Lecture 9:
Sorting Algorithms
김수경
이화여자대학교 인공지능융합전공 소속© 2025 Upstage Co., Ltd.
1
2저작권안내
(주)업스테이지가 제공하는 모든교육콘텐츠의 지식재산권은
운영주체인 (주)업스테이지 또는해당저작물의 적법한관리자에게 귀속되어 있습니다 .
콘텐츠일부또는전부를복사 , 복제 , 판매 , 재판매공개 , 공유등을할수없습니다 . 
유출될경우지식재산권 침해에대한책임을부담할수있습니다 . 
유출에해당하여 금지되는 행위의예시는다음과같습니다 . 
● 콘텐츠를 재가공하여 온/오프라인으로 공개하는 행위
● 콘텐츠의 일부 또는 전부를 이용하여 인쇄물을 만드는 행위
● 콘텐츠의 전부 또는 일부를 녹취 또는 녹화하거나 녹취록을 작성하는 행위
● 콘텐츠의 전부 또는 일부를 스크린 캡쳐하거나 카메라로 촬영하는 행위
● 지인을 포함한 제3자에게 콘텐츠의 일부 또는 전부를 공유하는 행위
● 다른 정보와 결합하여 Upstage Education 의콘텐츠임을 알아볼 수있는 저작물을 작성 , 공개하는 행위
● 제공된 데이터의 일부 혹은 전부를 Upstage Education 프로젝트 /실습 수행 이외의 목적으로 사용하는 행위
Insertion Sort in Life
The Great Dalmuti09 Sorting Algorithms
[1]http://www.partyhatpotato.com/reviews/2017/7/great -dalmuti -review.html[1] 
3
4Insertion Sort01
Sorting Problem
● Input: a list of Nnumbers
● Output: permutation B[1, …, n] of A such that B[1] ≤ B[2] ≤ … ≤ B[n]
○ In other words, a rearranged list of items in the input, such that they monotonically increase (or 
decrease).
● Example:
○ Input:
○ Expected output:Index 0 1 2 3 4 5 6 7 8 9
Value -7 15 2 6 -1 5 4 10 -4 21
Index 0 1 2 3 4 5 6 7 8 9
Value -7 -4 -1 2 4 5 6 10 15 2109 Sorting Algorithms
5
Why Sorting?
● Problems become easier once items are in sorted order:
○ Finding a median
○ Finding the closest pairs
○ Binary search
○ Identifying statistical outliers
● Various applications
○ Sorting a table by an attribute
○ Data compression: sorting finds duplicates.
609 Sorting Algorithms
[1]https://smart.dhgate.com/mastering -excel -sorting -step -by-step -techniques -to-organize -your -spreadsheet -like-a-pro/[1] 
(Human -like) Insertion Sort
● Main idea:
○ Start from an empty “sorted list” and a pile of items to sort.
○ For each item on the pile, put in the right position in the “sorted list”.
○ When there’s no item left in the pile, you are done.
Index 0 1 2 3 4 5 6 7 8 9
Value -7 15 2 6 -1 5 4 10 -4 21
Index
ValuePile
Sorted 
list
709 Sorting Algorithms
(Human -like) Insertion Sort
● Main idea:
○ Start from an empty “sorted list” and a pile of items to sort.
○ For each item on the pile, put in the right position in the “sorted list”.
○ When there’s no item left in the pile, you are done.
Index 0 1 2 3 4 5 6 7 8 9
Value -7 15 2 6 -1 5 4 10 -4 21
Index 0
Value -7Pile
Sorted 
list
809 Sorting Algorithms
(Human -like) Insertion Sort
● Main idea:
○ Start from an empty “sorted list” and a pile of items to sort.
○ For each item on the pile, put in the right position in the “sorted list”.
○ When there’s no item left in the pile, you are done.
Index 0 1 2 3 4 5 6 7 8 9
Value -7 15 2 6 -1 5 4 10 -4 21
Index 0 1
Value -7 15Pile
Sorted 
list
909 Sorting Algorithms
(Human -like) Insertion Sort
● Main idea:
○ Start from an empty “sorted list” and a pile of items to sort.
○ For each item on the pile, put in the right position in the “sorted list”.
○ When there’s no item left in the pile, you are done.
Index 0 1 2 3 4 5 6 7 8 9
Value -7 15 2 6 -1 5 4 10 -4 21
Index 0 1 2
Value -7 2 15Pile
Sorted 
list
1009 Sorting Algorithms
(Human -like) Insertion Sort
● Main idea:
○ Start from an empty “sorted list” and a pile of items to sort.
○ For each item on the pile, put in the right position in the “sorted list”.
○ When there’s no item left in the pile, you are done.
Index 0 1 2 3 4 5 6 7 8 9
Value -7 15 2 6 -1 5 4 10 -4 21
Index 0 1 2 3 4 5 6 7 8
Value -7 -4 -1 2 4 5 6 10 15Pile
Sorted 
list
1109 Sorting Algorithms
Insertion Sort
● Let’s do this in-place , without using an additional list.
○ Start from an empty “sorted listregion ” and a pile the region of items to sort.
○ For each item on the pile in the unsorted region , put in the right position in the “sorted listregion ”.
○ When there’s no item left in the pile unsorted region , you are done.
Index 0 1 2 3 4 5 6 7 8 9
Value -7 15 2 6 -1 5 4 10 -4 21
Sorted Unsorted
1209 Sorting Algorithms
Insertion Sort
● Let’s do this in-place , without using an additional list.
○ Start from an empty “sorted listregion ” and a pile the region of items to sort.
○ For each item on the pile in the unsorted region , put in the right position in the “sorted listregion ”.
○ When there’s no item left in the pile unsorted region , you are done.
Index 0 1 2 3 4 5 6 7 8 9
Value -7 15 2 6 -1 5 4 10 -4 21
Sorted Unsorted
1309 Sorting Algorithms
Insertion Sort
● Let’s do this in-place , without using an additional list.
○ Start from an empty “sorted listregion ” and a pile the region of items to sort.
○ For each item on the pile in the unsorted region , put in the right position in the “sorted listregion ”.
○ When there’s no item left in the pile unsorted region , you are done.
Index 0 1 2 3 4 5 6 7 8 9
Value -7 15 2 6 -1 5 4 10 -4 21
Sorted Unsorted
1409 Sorting Algorithms
Insertion Sort
● Let’s do this in-place , without using an additional list.
○ Start from an empty “sorted listregion ” and a pile the region of items to sort.
○ For each item on the pile in the unsorted region , put in the right position in the “sorted listregion ”.
○ When there’s no item left in the pile unsorted region , you are done.
Index 0 1 2 3 4 5 6 7 8 9
Value -7 2 15 6 -1 5 4 10 -4 21
Sorted Unsorted
1509 Sorting Algorithms
Insertion Sort
● Let’s do this in-place , without using an additional list.
○ Start from an empty “sorted listregion ” and a pile the region of items to sort.
○ For each item on the pile in the unsorted region , put in the right position in the “sorted listregion ”.
○ When there’s no item left in the pile unsorted region , you are done.
Index 0 1 2 3 4 5 6 7 8 9
Value -7 2 6 15 -1 5 4 10 -4 21
Sorted Unsorted
Index 0 1 2 3 4 5 6 7 8 9
Value -7 -4 -1 2 4 5 6 10 15 21
Sorted
1609 Sorting Algorithms
Insertion Sort: Implementation
def insertion_sort (list):
for i in range(1, len(list)):
key = list[i]
j = i -1
while j >=0 and key < list[j]:
list[j+1] = list[j]
j -= 1
list[j+1] = key
Index 0 1 2 3 4 5 6 7 8 9
Value -7 -1 2 5 6 15 4 10 -4 21
Sortedi
keyj
1709 Sorting Algorithms
Time Complexity
● At the i-th iteration, its inner loop (while) does:
○ Find the location to put the next item among         i items,
○ Shift all items on the right side by 1,
○ Put the target item at the found position.
● How many iterations?
● Overall complexity?
● If the input list is almost sorted, each iteration will be done by ≈O(1), so overall time complexity will be ≈O( N).? O(N)
O(N)
O(1)Complexity?
O(log N)if binary 
search used.
O(N)
O(N2)
1809 Sorting Algorithms
19Selection Sort02
Selection Sort
● Main idea: the opposite of insertion sort!
○ Instead of putting the next item in the right place,
○ Find the smallest item in the unsorted region, and
○ Swap it with the item in its right position.
Index 0 1 2 3 4 5 6 7 8 9
Value -7 15 2 6 -1 5 4 10 -4 21
Sorted UnsortedFind the smallest among unsorted ones.
The smallest is already in the target place 
2009 Sorting Algorithms
Selection Sort
● Main idea: the opposite of insertion sort!
○ Instead of putting the next item in the right place,
○ Find the smallest item in the unsorted region, and
○ Swap it with the item in its right position.
Index 0 1 2 3 4 5 6 7 8 9
Value -7 15 2 6 -1 5 4 10 -4 21
Sorted UnsortedFind the smallest among unsorted ones.
Swap it with the one at the target position.
2109 Sorting Algorithms
Selection Sort
● Main idea: the opposite of insertion sort!
○ Instead of putting the next item in the right place,
○ Find the smallest item in the unsorted region, and
○ Swap it with the item in its right position.
Index 0 1 2 3 4 5 6 7 8 9
Value -7 -4 2 6 -1 5 4 10 15 21
Sorted UnsortedFind the smallest among unsorted ones.
Swap it with the one at the target position.
2209 Sorting Algorithms
Selection Sort
● Main idea: the opposite of insertion sort!
○ Instead of putting the next item in the right place,
○ Find the smallest item in the unsorted region, and
○ Swap it with the item in its right position.
Index 0 1 2 3 4 5 6 7 8 9
Value -7 -4 -1 6 2 5 4 10 15 21
Sorted UnsortedFind the smallest among unsorted ones.
Swap it with the one at the target position.
Repeat until there is no item left in the unsorted region!
2309 Sorting Algorithms
Selection Sort: Implementation
def selection_sort (list):
for i in range(len(list)):
smallest = i
for j in range(i+1, len(list)):
if list[j] < list[smallest]:
smallest = j
list[i], list[smallest] = list[smallest], list[i]
Index 0 1 2 3 4 5 6 7 8 9
Value -7 -4 -1 6 10 5 4 2 15 21
Sortedi
smallestswap
Q. Can you implement this with recursion?
2409 Sorting Algorithms
Time Complexity
● At the i-th iteration, its inner loop (for) does:
○ Find the smallest items among         N-i unsorted items,
○ Swap it with the item at the next position.
● How many iterations?
● Overall complexity?
● No benefit even though the input list is almost sorted.
○ When we find the next smallest item, we do not assume the remaining list is sorted.?O(N)
O(1)Complexity?
O(N)
O(N2)
2509 Sorting Algorithms
26Merge Sort03
Motivation
● Insertion sort and selection sort work but too slow.
○ Time complexity is O( N2).
○ Does not matter when handling small data, but we want to handle big data !
● Any better idea?
○ Divide and conquer!
2709 Sorting Algorithms
Merge Sort
● Main idea:
○ Divide the whole list into two sub -lists.
○ Sort the left and right sublists separately .
○ Merge the two sorted sublists into a single sorted one.
Index 0 1 2 3 4 5 6 7
Value 5 -2 0 10 -6 7 4 9
Index 0 1 2 3
Value -2 0 5 10Index 0 1 2 3
Value -6 4 7 9
Index 0 1 2 3 4 5 6 7
Value -6 -2 0 4 5 7 9 10Sort Sort
Merge
2809 Sorting Algorithms
Merge Sort
● Further breakdown: each sublist is also sorted in a similar way!
5 -2 0 10 -6 7 4 9
5 -2 0 10 -6 7 4 9
5 -2 0 10-6 74 9
5 -2 0 10-6 74 9Okay, dividing is easy!
Sorting each separately is also easy, as they have just a single item in the end.
2909 Sorting Algorithms
Merge Sort
● Further breakdown: each sublist is also sorted in a similar way!
-6 -2 0 4 6 7 9 10
-2 0 5 10 -6 4 7 9
-2 5 0 10-6 74 9
5 -2 0 10-6 7 4 9
What about merging?!
3009 Sorting Algorithms
Merge Sort
● At each step, the only non -trivial task is merging two sorted arrays into a single sorted array.
-6 -2 0 4 6 7 9 10
-2 0 5 10 -6 4 7 9
● First trial with brute force:
○ Concatenate the two list
○ Sort the entire list with insertion (or selection) sort.
○ Time complexity?
■ 1st split: 2 ×(N/2)2, 2st split: 4 ×(N/4)2, 3rd split: 8 ×(N/8)2, …
■ In total, O( N2). No benefit from directly sorting entire matrix at once.
3109 Sorting Algorithms
Merge Sort
● So, we need more efficient merging, taking advantage of the fact that the two sublists are already sorted .
-2 0 5 10 -6 4 7 9● The first (smallest) item must be either the smallest item in the left sublist or the smallest one in the right 
sublist.
-6
3209 Sorting Algorithms
Merge Sort
● Then, what about the next one?
-6
-2 0 5 10 -6 4 7 9● The second smallest item must be either the smallest item in the left sublist or the second smallest one in the 
right sublist (since -6 was already used).
-2
3309 Sorting Algorithms
Merge Sort
● In a similar way, we choose the smaller one between the smallest remaining items in each list at a time, until 
both lists are completely consumed.
-6 -2
-2 0 5 10 -6 4 7 90 4 5 7 9 10
Now, both sublists are all used!
3409 Sorting Algorithms
Merge Sort: Time Complexity
● Time complexity of this merging step?
○ At each time we fill the output, we
■ Compare two elements once → O(1)
■ Write the small one → O(1)
■ Move one pointer on the selected side → O(1)
○ How many times do we repeat this?
■ Same as the output list size!
■ 1st split: 2 ×(N/2), 2nd split: 4 ×(N/4), … → O(N)
-6 -2
-2 0 5 10 -6 4 7 90 4 5 7 9 10
3509 Sorting Algorithms
Merge Sort: Time Complexity
● How many steps do we have?
○ Same as the height of this tree: O(log N)
-6 -2 0 4 6 7 9 10
-2 0 5 10 -6 4 7 9
-2 5 0 10 -6 7 4 9
5 -2 0 10 -6 7 4 9So, overall time complexity is: O(Nlog N)
3609 Sorting Algorithms
Merge Sort: Implementation
def merge_sort (list):
if len(list) > 1:
mid = len(list) // 2 # round down
left = list[:mid]
right = list[mid:]
merge_sort (left)
merge_sort (right)
# TODO(students): merge left & right in the list
“else ” for this is the base case , where the recursive calls are done.
We skip it here, since there’s no action item in the base case.
3709 Sorting Algorithms
Merge Sort vs. Insertion Sort
● How different the speed is, between O(N2)vs. O(Nlog N)?
N NTime (sec)
3809 Sorting Algorithms
Can we do better?
● Insertion / Selection sort takes O(N2).
● Merge sort takes O(Nlog N).
● Can we do better?
What is the best possible time complexity for sorting problem?
Then, can we sort in O( N)?O(N), because we need O( N) to read the input list anyway.
Yes, if we have some additional conditions.
(It was proved that O( Nlog N) is the best for comparison -based sorting algorithms.)
3909 Sorting Algorithms
40Linear Time Sorting: O (n)04
Counting Sort
● A linear -time sorting algorithm under the condition that the input elements are always integers between 0 and 
k.
● Example:
4109 Sorting Algorithms
[1]https://eprints.upj.ac.id/id/eprint/9958/13/BAB%20III.pdf[1] 
Counting Sort
● Intuitive example: N= 7, k= 7
5725157[0] [1] [2] [3] [4] [5] [6] [7]
7 5 1
5
572
1 2 5 5 5 7 7Stable sort : the original 
order is preserved for 
items with the same key.
4209 Sorting Algorithms
Counting Sort
● Algorithm
○ Reading the entire input list, increase the number of occurrences of each key.
○ Take cumulative sum of this counts.
→ This is the ending index of each number in the sorted output.7 5 1 5 2 7 5
[0] [1] [2] [3] [4] [5] [6] [7]
0 1 1 0 0 3 0 2
[0] [1] [2] [3] [4] [5] [6] [7]
0 1 2 2 2 5 5 7
0:0 0:1 1:2 2:2 2:2 2:5 5:5 5:7
4309 Sorting Algorithms
Counting Sort
● Algorithm
○ Read the input list once again from backward ,
○ Subtract the target index by 1,
○ Put the element there, and move on.7 5 1 5 2 7 5
[0] [1] [2] [3] [4] [5] [6] [7]
0 1 2 2 2 5 5 7
0:1 1:2 2:2 2:2 2:5 5:5 5:7
[0] [1] [2] [3] [4] [5] [6]4
5 71
23
5Why backward?
→ For stable sort!
4409 Sorting Algorithms
6
Counting Sort: Implementation
def counting_sort (list):
output = [0] * (len(list))
count = [0] * (max(list) + 1)
for i in range(len(list)):
count[list[i]] += 1
for i in range(1, len(count)):
count[i] += count[i -1]
for i in range(len(list)):
j = len(list) -1 -i
count[list[j]] -= 1
index = count[list[j]]
output[index] = list[j]
return outputCount occurrences of each key.
Cumulative sum
Locate each element at the right position in 
the output.Time complexity?
O(N)
O(k)
O(N)
Overall, O(N+ k).
If k≤ N, counting sort runs in linear time on the input 
size ( N).
4509 Sorting Algorithms
Sorting in Reality
● What sorting algorithm is used in Python library?
○ Timsort (2002) : a hybrid sorting algorithm (merge sort + insertion sort)
■ A variant of merge sort (divide and conquer)
■ When a sublist becomes smaller than some threshold, it is sorted using insertion sort.
■ Insertion sort is faster than merge sort for a small list.
● If your data is small enough, insertion/selection sort may work okay.
● Otherwise, merge sort or quick sort is recommended.
● You may consider a linear -time sorting if your key is integer within a reasonable range. However, it may be hard 
to take advantage unless the dataset is really huge, and you implement efficiently.
4609 Sorting Algorithms
Problem  1
def selection_sort (list):
for i in range(len(list)):
smallest = i
for j in range(i+1, len(list)):
if list[j] < list[smallest]:
smallest = j
list[i], list[smallest] = list[smallest], list[i]
Index 0 1 2 3 4 5 6 7 8 9
Value -7 -4 -1 6 10 5 4 2 15 21
Sortedi
smallestswapQ. Can you implement this with selection sort with  recursion?
4709 Sorting Algorithms
Problem  2
def merge_sort (list):
if len(list) > 1:
mid = len(list) // 2
left = list[:mid]
right = list[mid:]
merge_sort (left)
merge_sort (right)
# TODO(students): merge left & right in the list
“else ” for this is the base case , where the recursive calls are done.
We skip it here, since there’s no action item in the base case.Q. Please implement merge sort. (# TODO section below)
4809 Sorting Algorithms
www.upstage.ai © 2025 Upstage Co., Ltd.

