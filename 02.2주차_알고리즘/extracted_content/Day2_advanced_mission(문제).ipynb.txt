# Day 2. 스택으로 문제 해결하기 – 심화 미션 (Daily Temperatures)

이 노트북은 **Monotonic Stack(단조 스택)** 패턴을 연습하기 위한 심화 과제용입니다.
LeetCode **#739 Daily Temperatures** 문제를 풀며, 스택을 이용한 **인덱스 기반 문제 해결**을 경험합니다.

## 🎯 학습 목표
- 스택에 **값이 아닌 인덱스(index)** 를 저장하여 문제를 푸는 패턴을 익힌다.
- **Monotonic Stack(단조 증가/단조 감소 스택)** 의 개념을 이해하고 구현한다.
- 온도 배열에서 "다음에 더 따뜻한 날"까지의 거리를 효율적으로 계산한다.

---
## 문제: LeetCode #739 — Daily Temperatures

정수 배열 `temperatures` 가 주어질 때, **각 날짜마다** 현재 온도보다 더 따뜻한 날이 오기까지
몇 일을 기다려야 하는지 계산해서 배열로 반환하세요.

더 따뜻한 날이 없다면 `0`을 기록합니다.

### 예시
1. `temperatures = [73,74,75,71,69,72,76,73]`
   → 출력: `[1,1,4,2,1,1,0,0]`
2. `temperatures = [30, 40, 50, 60]`
   → 출력: `[1,1,1,0]`
3. `temperatures = [30, 60, 90]`
   → 출력: `[1,1,0]`

### 제한 조건
- `1 <= temperatures.length <= 10**5`
- `30 <= temperatures[i] <= 100`

---
아래 **Step 1 → Step 3** 순서로 심화 미션을 진행하세요.

## 🛠️ Prerequisites
본 미션은 Python 표준 라이브러리만을 사용하여 해결하며, 다음 모듈을 활용합니다.
* **`from typing import List`**: 리스트 데이터의 타입을 명시하기 위해 사용합니다.
* 별도의 라이브러리 설치(pip install)는 필요하지 않으며, Python 3.x 환경에서 즉시 실행 가능합니다.

## Step 1. 문제 이해 & 단순(Brute Force) 아이디어 생각해 보기

먼저, 스택 없이 **가장 단순한 방법**을 떠올려 보고 시간복잡도를 분석해 봅시다.

- i번째 날에 대해, 그 다음 날들 `i+1, i+2, ...` 을 하나씩 보면서
  **처음으로 더 따뜻한 날**을 찾는 방식은 어떤 시간복잡도를 가질까요?
- 이 방식이 `O(N^2)` 인 이유를 설명해 보세요.

아래에 본인의 생각을 정리해 보세요.

### ✏️ Brute Force 아이디어 & 시간복잡도 (학생 작성)

- 단순한 해결 방법 설명: 오늘부터 시작해서 오늘보다 따듯한 날이 나올 때까지, 내일, 모레를 하나씩 다 확인해본다,브루트포스
- 1.리스트의 첫 날부터 마지막 날까지 하나씩 선택(선택일)
- 2.선택일 이후의 날들을 하나씩 살펴보며 선택일보다 온도가 높은 날을 찾음
- 3.찾으면 그날과 선택일의 날짜차이(인덱스차이)를 결과리스트에 적는다
- 4.끝까지 가도 더 따듯한 날이 없다면 0을 적는다
- 이 방법의 시간복잡도 분석 (왜 O(N^2)?):
  -주어진 N개의 모든 날짜마다 뒤에 남은 모든 날을 확인해야하므로 N회차
  -N*N
- N 이 10만(`10**5`)일 때, 이 방법이 왜 비효율적인지:
  -10**10만큼 해야하니 시간이 오래걸린다.


---
## Step 2. Monotonic Stack(단조 스택) 아이디어 이해하기

### Monotonic Stack이란?
- 스택 안의 원소들이 **항상 한 방향으로 정렬된 상태(단조 증가 / 단조 감소)** 를 유지하도록 관리하는 스택입니다.
- 이 문제에서는 "미래의 더 큰 값"을 빠르게 찾기 위해, **온도가 높은 날을 찾을 때까지** 이전 인덱스를 스택에 쌓아두었다가,
  더 따뜻한 날을 만나면 스택에서 꺼내면서 거리(날짜 차이)를 계산합니다.

### 핵심 아이디어 (단조 감소 스택)
- 스택에는 **인덱스(index)** 를 저장합니다.
- 스택 안의 인덱스들은 항상 **온도가 내림차순(같거나 더 높은)** 이 되도록 유지합니다.
- 새로운 날 `i`의 온도 `temperatures[i]` 가 **스택 top의 온도보다 높다면**, 그 날이 바로
  스택 top에 쌓여 있던 날짜들의 "다음 더 따뜻한 날"이 됩니다.
- 이 과정을 반복하면서, 한 번씩만 스택에 `push`/`pop` 하면 전체 시간복잡도는 `O(N)` 이 됩니다.

위 내용을 스스로 이해한 표현으로 아래에 다시 요약해 보세요.

### ✏️ Monotonic Stack 정리 (학생 작성)

- 스택에 **값이 아닌 인덱스를 저장**하는 이유:
  -날짜차이를 계산해야하기 때문에
  -값인 온도만 저장하면 며칠 뒤인지 알 수 없다
  -인덱스 자체가 날짜의 역할을 한다. 인덱스 차로 며칠 뒤인지 알 수 있다,
  -해당 인덱스로 온도값도 볼 수 있다.
- 우리가 유지하려는 "단조성"(증가/감소)은 어떤 방향이며, 그 이유는?
  -스택 아래쪽이 높고, 위로갈수록 낮은 온도
  -현재온도보다 더 따듯한 날을 아직 찾지 못한 날짜들이, 온도가 높은 순서에서
  -낮은 순서로 쌓인다.
  -만약 선택일의 온도가 전일 보다 낮다면, 기다려야하므로 선택일은 스택에 추가된다
  -만약 선택일의 온도가 전일 보다 높다면, 데이터를 꺼낸다
- 새로운 온도를 만났을 때, 스택에서 `pop` 해야 하는 조건은?
  -선택일의 온도 > 스택 탑 인덱스 온도


---
## Step 3. Python 코드 구현 – `dailyTemperatures`

아래 템플릿을 참고해서 Monotonic Stack 기반 알고리즘을 구현해 보세요.

### 구현 요구사항
- 반환값: 각 인덱스 `i`에 대해, **더 따뜻한 날까지 기다려야 하는 일수**를 담은 리스트
- 더 따뜻한 날이 없으면 `0`
- 시간복잡도: `O(N)`
- 스택에는 **인덱스만 저장**합니다.


 """Daily Temperatures 문제를 Monotonic Stack으로 해결합니다.

        아이디어 요약:
            TODO: 단조 스택이 어떻게 동작하는지, 간단히 한국어로 정리해 보세요.

           ///////////////// 정리가 안되어요! 살려줘///////////////////

        시간복잡도:
            TODO: 왜 이 알고리즘이 O(N)인지 설명해 보세요.
        """

from typing import List

class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
       
        n = len(temperatures)
        answer = [0] * n  # 각 인덱스별 정답을 저장할 배열

        stack = []  # 인덱스를 저장하는 스택 (단조 감소 스택)

        # TODO: 여기에 Monotonic Stack 알고리즘을 구현하세요.
        for curr_day, curr_temp in enumerate(temperatures):
        
        #   - i를 0부터 n-1까지 순회
            while stack and curr_temp > temperatures[stack[-1]]:
                prev_day = stack.pop()
                answer[prev_day] = curr_day - prev_day
        #   - 현재 온도가 스택 top 인덱스의 온도보다 높으면, pop 하면서
        #     answer[top] = i - top  값을 채우기

            stack.append(curr_day)
        return answer
        #   - 스택에는 항상 아직 더 따뜻한 날을 찾지 못한 인덱스만 남도록 유지

        raise NotImplementedError


### ✅ 테스트 코드
아래 셀을 실행해 예제 입력과 몇 가지 추가 케이스에 대해 결과를 확인해 보세요.
필요하다면 테스트 케이스를 직접 더 추가해도 좋습니다.

def run_tests():
    sol = Solution()
    tests = [
        ([73,74,75,71,69,72,76,73], [1,1,4,2,1,1,0,0]),
        ([30,40,50,60], [1,1,1,0]),
        ([30,60,90], [1,1,0]),
        ([100, 90, 80], [0,0,0]),  # 항상 감소하는 경우
    ]

    for temps, expected in tests:
        result = sol.dailyTemperatures(temps)
        print(f"temperatures={temps}\n  result  = {result}\n  expected= {expected}\n")

run_tests()


---
## Step 4. 정리 및 자기 점검

아래에 오늘의 심화 미션에서 배운 점을 정리해 보세요.

- Monotonic Stack 패턴을 다른 문제(예: "Next Greater Element")에 어떻게 응용할 수 있을까요?
- 단순 `O(N^2)` 방식과 비교했을 때, 구현 난이도와 직관성은 어땠나요?

### ✏️ 정리 (학생 작성)

- 오늘 새로 알게 된 개념/키워드:
  -inkedlist stack queue lifo fifo 시간,공간복잡도 꼬리포인터
- Monotonic Stack을 한 문장으로 정의해 본다면:
  -스택 내부 원소들을 일정한 순서로 유지
- 이 패턴을 적용할 수 있을 것 같은 다른 문제 유형:
  -


---
## 제출 전 체크리스트 ✅ (심화)
- [ ] `dailyTemperatures` 함수가 **O(N)** 시간복잡도로 구현되었다.
- [ ] 스택에는 **온도가 아니라 인덱스**를 저장한다.
- [ ] 스택 `pop` 조건과 `answer[index] = i - index` 계산이 정확하다.
- [ ] 예시 테스트 케이스가 모두 올바르게 통과한다.
- [ ] Monotonic Stack의 개념을 말로 설명할 수 있다.

잘 해냈어요! 💪 Day 2 심화에서 배운 Monotonic Stack은 이후 여러 고급 문제에서 반복해서 등장할 핵심 도구입니다.

###**콘텐츠 라이선스**
<font color='red'><b>**(주)업스테이지가 제공하는 모든 교육 콘텐츠의 지식재산권은
운영 주체인 (주)업스테이지 또는 해당 저작물의 적법한 관리자에게 귀속되어 있습니다.**</b></font>

콘텐츠 일부 또는 전부를 **복사, 복제, 판매, 재판매 공개, 공유** 등을 할 수 없습니다. 유출될 경우 지식재산권 침해에 대한 책임을 부담할 수 있습니다.

유출에 해당하여 금지되는 행위의 예시는 다음과 같습니다.
* 콘텐츠를 재가공하여 온/오프라인으로 공개하는 행위
* 콘텐츠의 일부 또는 전부를 이용하여 인쇄물을 만드는 행위
* 콘텐츠의 전부 또는 일부를 녹취 또는 녹화하거나 녹취록을 작성하는 행위
* 콘텐츠의 전부 또는 일부를 스크린 캡쳐하거나 카메라로 촬영하는 행위
* 지인을 포함한 제3자에게 콘텐츠의 일부 또는 전부를 공유하는 행위
* 다른 정보와 결합하여 Upstage Education의 콘텐츠임을 알아볼 수 있는 저작물을 작성, 공개하는 행위
* 제공된 데이터의 일부 혹은 전부를 Upstage Education 프로젝트/실습 수행 이외의 목적으로 사용하는 행위