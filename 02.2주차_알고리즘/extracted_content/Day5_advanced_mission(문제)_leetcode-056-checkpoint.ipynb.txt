# Day 5. 구간 병합 알고리즘 – 심화 미션
## LeetCode #56 — Merge Intervals

이 노트북은 Day 5 심화 과제인 **정렬 + 병합(sweep)** 패턴을 구현하기 위한 학생용 템플릿입니다.

---
## 🎯 학습 목표
- 정렬된 구간(intervals)을 순차적으로 탐색하며 병합하는 알고리즘을 이해한다.
- "정렬 → 선형 스캔 → 조건 분기" 패턴을 구현한다.
- 병합 조건(`start <= last_end`)을 정확히 다룬다.
- 시간복잡도 O(n log n) + O(n) 을 설명할 수 있다.

---
## 📌 문제 설명
서로 겹치는 모든 구간(intervals)을 병합하여, 병합된 구간만 포함하는 배열을 반환하세요.

### 예시
입력: `[[1,3],[2,6],[8,10],[15,18]]`
출력: `[[1,6],[8,10],[15,18]]`

---
## 🛠️ Prerequisites
본 미션은 효율적인 데이터 처리를 위해 파이썬 내장 모듈을 활용합니다.
* **`import heapq`**: 최소 힙(min-heap)을 사용하여 $O(n \log k)$의 시간복잡도로 문제를 해결합니다.
* **`from typing import List`**: 리스트 데이터의 타입을 명시하기 위해 사용합니다.
* 별도의 설치 없이 Python 3.x 환경의 표준 라이브러리만으로 실행 가능합니다.

---
## Step 1. 문제 이해 & 예시 분석
병합조건을 조건으로 시작과 끝의 겹치는 구간을 하나로 병합하여 시작과 끝점을 도출한다

### ✏️ 예시 분석 (학생 작성)
- 왜 [1,3] 과 [2,6] 은 병합되는가?
- 1~3구간에  2~6구간의 시작이 겹친다, 병합하여 1~6 구간이 된다
- 앞 구간의 끝나는 점이, 뒷 구간의 시작점보다 크거나 같다면 겹친다
- 왜 [8,10] 과 [15,18] 은 병합되지 않는가?
- 8~10과 15~18은 각 끝점과 시작점 사이 겹치는 구간이 없다.

---
## Step 2. 핵심 패턴 파악하기 — "정렬 후 선형 스캔"

병합 알고리즘의 핵심 단계는 다음과 같습니다:
1. intervals 를 시작점을 기준으로 정렬한다.
2. 결과 리스트 `merged = []` 를 준비한다.
3. intervals 를 앞에서부터 탐색한다.
4. merged 가 비어있거나, 현재 구간이 이전 구간과 겹치지 않는다면 → append
5. 겹친다면 → 이전 구간의 end 값을 max(end, new_end) 로 갱신

아래에 스스로 요약해보세요.

### ✏️ 병합 조건 요약 (학생 작성)
- 겹친다고 판단하는 조건:
- 앞 구간의 끝나는 점이, 뒷 구간의 시작점보다 크거나 같다면 겹친다
- Interval_A[1] >= Interval_B[0]
- 
- 겹치지 않는다고 판단하는 조건:
- 앞 구간의 끝나는 점이, 뒷 구간의 시작점보다 작다면 겹치지 않는다.
- nterval_A[1] < Interval_B[0]
- 
- 병합 시 업데이트해야 하는 값: 앞 구간의 끝점을 , 뒷 구간의 끝점으로 업데이트
- 앞구간이 뒷구간을 완전히 포함하고 있는 경우도 있을 수 있다!!
- 앞구간의 끝점을 앞구간의 끝점과 뒷구간의 끝점 중 더 큰 값으로 업데이트 해야 함!
-  max(앞 구간 끝점, 뒷구간 끝점)




---
## Step 3. 코드 템플릿 완성하기
`TODO` 부분을 직접 채워 넣어 문제를 해결하세요.


from typing import List

class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        """
        intervals를 병합하여 새로운 리스트를 반환합니다.
        알고리즘 구조:
        1) 정렬
        2) 선형 스캔하며 병합
        """

        # 1) intervals 정렬
        # TODO: 시작점 기준으로 정렬하기
        for i in range(len(intervals)):
            smallest = i
            for j in range(i+1, len(intervals)):
                if intervals[j][0] < intervals[smallest][0]:
                    smallest = j
            intervals[i], intervals[smallest] = intervals[smallest], intervals[i]
        
        merged = []
        #위에서 전부 시작점기준으로 소팅해놨으니까 시작점끼리 겹치는것 없고, 
        #오름차순이야
        
        # 2) 병합 진행
        for interval in intervals: #intervals 에 있는 각 인덱스들을 꺼내서 볼꺼야
            start, end = interval  #그 리스트들의 인덱스를 각각 start, end 라고 하자고
            
            # TODO: merged가 비었거나, 겹치지 않는 경우 → 새 구간 추가
            if not merged:
                merged.append(interval) #merged가 비었잖아?, 그 interval값을 추가해
                #그래서 merged가 생겼지? 
                #start(interval[0]) > merged[-1][1](merged 마지막인덱스의 end값) 이면 안겹쳐, 
                #추가해
            if start > merged[-1][1]: #이게 겹치지 않는 경우야. 바로 추가해
                merged.append(interval)

            if start <= merged[-1][1]:
                #앞구간이 뒷구간을 완전히 포함할 수도 있으니까
                #앞구간 끝점과 뒷구간 끝점중 큰것을 골라서
                #merged의 마지막 값의 끝점에 넣어.
                #왜냐하면, 이 경우는 앞구간과 뒷구간이 겹치는 경우잖아?
                #병합했을 때 앞구간의 시작점을 따르니까, append할게 아니라
                # 앞구간의 끝점을 앞구간과 뒷구간의 끝점중 큰 값으로 하는거야
                #이해함?
                merged[-1][1] = max(merged[-1][1],end) #interval의 [1]을 end로 하자고 했어

            # TODO: 겹치는 경우 → 마지막 구간의 end 업데이트
            #       max(old_end, end)

            ##if만 사용한 코드를 if/else로 바꿀 수 있겠으나
            ##이해의 측면에서 냅둠.
            ##어차피 append하는 not merged와 겹치지 않는 경우는 or로 합치고,
            ##마지막 겹치는 부분은 조건 떼고, else 로 두면 됩니다!
        

        return merged


---
## Step 4. 테스트 수행
실행하여 결과가 맞는지 확인하세요.


def run_tests():
    sol = Solution()
    tests = [
        ([[1,3],[2,6],[8,10],[15,18]], [[1,6],[8,10],[15,18]]),
        ([[1,4],[4,5]], [[1,5]]),
        ([[1,2],[3,4]], [[1,2],[3,4]]),
        ([[1,10],[2,3],[4,5]], [[1,10]]),
    ]

    for intervals, expected in tests:
        result = sol.merge(intervals)
        print(f"intervals={intervals} → result={result}, expected={expected}")

run_tests()


---
## Step 5. 시간복잡도 분석 & 정리


### ✏️ 복잡도 분석 (학생 작성)
- 정렬 단계 시간복잡도:O(N^2) 선택정렬을 사용했고,  전체 리스트 N번 돌면서 N개 다 살펴봐야함, N*N 의 비교
- 병합 단계(time):O(N) 소팅된 각 인덱스들 한번씩 다 살펴봐야하므로 
- 총 시간복잡도:N^2 + N 인데 오래걸리는 단계만 남으므로 O(N^2)
- 공간복잡도: 정렬단계에서는 in-place로 해결했으나, O(1), 병합단계에서 merged라는 리스트를 별도로 만들어야 했으므로 O(N)


---
## 제출 전 체크리스트
- [ ] intervals 정렬을 올바르게 했는가?
- [ ] 병합 조건을 정확히 구현했는가?
- [ ] 다양한 테스트로 검증했는가?
- [ ] 시간복잡도를 설명할 수 있는가?

수고했습니다! Day 5까지 완료하면 자료구조 문제 해결의 핵심 패턴을 모두 한 번씩 경험했습니다 🎉


###**콘텐츠 라이선스**
<font color='red'><b>**(주)업스테이지가 제공하는 모든 교육 콘텐츠의 지식재산권은
운영 주체인 (주)업스테이지 또는 해당 저작물의 적법한 관리자에게 귀속되어 있습니다.**</b></font>

콘텐츠 일부 또는 전부를 **복사, 복제, 판매, 재판매 공개, 공유** 등을 할 수 없습니다. 유출될 경우 지식재산권 침해에 대한 책임을 부담할 수 있습니다.

유출에 해당하여 금지되는 행위의 예시는 다음과 같습니다.
* 콘텐츠를 재가공하여 온/오프라인으로 공개하는 행위
* 콘텐츠의 일부 또는 전부를 이용하여 인쇄물을 만드는 행위
* 콘텐츠의 전부 또는 일부를 녹취 또는 녹화하거나 녹취록을 작성하는 행위
* 콘텐츠의 전부 또는 일부를 스크린 캡쳐하거나 카메라로 촬영하는 행위
* 지인을 포함한 제3자에게 콘텐츠의 일부 또는 전부를 공유하는 행위
* 다른 정보와 결합하여 Upstage Education의 콘텐츠임을 알아볼 수 있는 저작물을 작성, 공개하는 행위
* 제공된 데이터의 일부 혹은 전부를 Upstage Education 프로젝트/실습 수행 이외의 목적으로 사용하는 행위