# Day 1. 배열과 알고리즘으로 문제 해결하기 – 심화 미션

이 노트북은 **in-place 배열 조작**과 **two-pointer 전략**을 연습하기 위한 심화 과제용입니다.

## 🎯 학습 목표
- 추가 메모리를 거의 사용하지 않는 **in-place 알고리즘** 개념을 이해한다.
- **two-pointer 패턴(write/read 포인터 등)** 을 실제 문제에 적용해본다.
- 간단한 최적화를 통해 전체 연산 횟수를 줄이는 아이디어를 연습한다.

---
## 오늘의 심화 문제: LeetCode #283 – Move Zeroes

정수 배열 `nums`가 주어질 때,
배열 안의 모든 `0`을 **배열의 뒤쪽으로 이동**시키되,
`0이 아닌 원소들의 상대적 순서는 유지`하도록 배열을 재배치하세요.

이 작업은 **in-place**, 즉 **새로운 배열을 생성하지 않고** 수행해야 합니다.

### 예시
1. 입력: `nums = [0, 1, 0, 3, 12]` → 출력: `[1, 3, 12, 0, 0]`
2. 입력: `nums = [0]` → 출력: `[0]`

### 제한 조건
- `1 <= nums.length <= 10^4`
- `-2^31 <= nums[i] <= 2^31 - 1`

### Follow-up
- 전체 연산(스왑/대입)의 횟수를 어떻게 하면 최소화할 수 있을까요?


## 🛠️ Prerequisites
본 미션에서는 다음과 같은 Python 표준 라이브러리를 사용합니다.
* **`from typing import List`**: `nums` 배열의 타입을 명시하기 위해 사용합니다.
* 별도의 외장 라이브러리 설치 없이 기본 Python 환경에서 실행 가능합니다.

---
## Step 1. Two-pointer로 `moveZeroes` 구현하기

### 아이디어 힌트
- 하나의 포인터는 **현재 읽고 있는 위치(read)** 를 가리킵니다.
- 다른 포인터는 **0이 아닌 값을 쓸 위치(write)** 를 가리킵니다.
- `nums`를 앞에서부터 순회하면서, 0이 아닌 값을 발견하면 `write` 위치에 옮기고 `write`를 한 칸 증가시킵니다.
- 마지막에 `write` 뒤에 남은 위치들을 모두 0으로 채웁니다.

아래 템플릿을 활용해 코드를 완성해 보세요.

from typing import List

class Solution:
  def moveZeroes(self, nums: List[int]) -> None:
      """nums 리스트 안의 모든 0을 뒤로 보내고,
      0이 아닌 원소들의 상대적 순서를 유지하도록 in-place로 수정합니다.

      시간복잡도 & 아이디어:
          TODO: 사용한 two-pointer 전략과 시간복잡도(O(N))를 설명해 보세요.
      """
      # TODO: two-pointer(write/read) 방식으로 구현해 보세요.
      #   - 추가 리스트를 만들지 말고(nums를 그대로 수정) in-place로 해결해야 합니다.
      #   - 필요하다면 포인터 변수(write, read)를 두고, 반복문을 한 번만 도는 구현을 시도해 보세요.



### ✅ 테스트 코드
아래 셀을 실행해 다양한 케이스에서 함수가 잘 동작하는지 확인해 보세요.
테스트를 **스스로 1~2개 더 추가**하면 더 좋습니다!

def test_move_zeroes(nums):
    print(f"입력  before: {nums}")
    Solution().moveZeroes(nums)
    print(f"출력  after : {nums}\n")

test_cases = [
    [0, 1, 0, 3, 12],
    [0],
    [1, 2, 3],
    [0, 0, 0, 1],
]

for case in test_cases:
    test_move_zeroes(case)


---
## Step 2. 연산 횟수와 최적화 아이디어

아래에 본인이 구현한 알고리즘의 **시간복잡도와 연산 패턴**을 정리해 보세요.

- 우리는 리스트를 몇 번 순회했나요?
- 불필요한 스왑/대입 연산을 줄일 수 있는 방법은 무엇인가요?
- 두 포인터를 활용함으로써 **전체 복잡도를 어떻게 유지(O(N))** 했는지 설명해 보세요.

---

### ✏️ 정리 (학생 작성)

- 내가 사용한 포인터의 역할:
  -
- 전체 시간복잡도와 그 이유:
  -
- 연산 횟수를 더 줄일 수 있는 아이디어가 있다면:
  -


---
## 제출 전 체크리스트 (심화)
- [ ] `moveZeroes`가 **in-place**로 동작한다. (새 리스트를 만들지 않았다)
- [ ] 두 포인터 아이디어를 코드에 반영했다.
- [ ] 최소 3개 이상의 테스트 케이스를 실행해 보았다.
- [ ] 시간복잡도와 알고리즘 아이디어를 말/글로 설명할 수 있다.

수고 많았어요! 👏 배열 알고리즘과 two-pointer 패턴은 이후에도 계속 반복해서 등장합니다.


###**콘텐츠 라이선스**
<font color='red'><b>**(주)업스테이지가 제공하는 모든 교육 콘텐츠의 지식재산권은
운영 주체인 (주)업스테이지 또는 해당 저작물의 적법한 관리자에게 귀속되어 있습니다.**</b></font>

콘텐츠 일부 또는 전부를 **복사, 복제, 판매, 재판매 공개, 공유** 등을 할 수 없습니다. 유출될 경우 지식재산권 침해에 대한 책임을 부담할 수 있습니다.

유출에 해당하여 금지되는 행위의 예시는 다음과 같습니다.
* 콘텐츠를 재가공하여 온/오프라인으로 공개하는 행위
* 콘텐츠의 일부 또는 전부를 이용하여 인쇄물을 만드는 행위
* 콘텐츠의 전부 또는 일부를 녹취 또는 녹화하거나 녹취록을 작성하는 행위
* 콘텐츠의 전부 또는 일부를 스크린 캡쳐하거나 카메라로 촬영하는 행위
* 지인을 포함한 제3자에게 콘텐츠의 일부 또는 전부를 공유하는 행위
* 다른 정보와 결합하여 Upstage Education의 콘텐츠임을 알아볼 수 있는 저작물을 작성, 공개하는 행위
* 제공된 데이터의 일부 혹은 전부를 Upstage Education 프로젝트/실습 수행 이외의 목적으로 사용하는 행위