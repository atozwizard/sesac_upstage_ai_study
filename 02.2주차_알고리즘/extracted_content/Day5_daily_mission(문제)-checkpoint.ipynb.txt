# Day 5. 동적 프로그래밍 기초 – 데일리 미션
## LeetCode #70 — Climbing Stairs

이 노트북은 Day 5 데일리 미션인 **Climbing Stairs (DP)** 문제를 풀이하기 위한 학생용 템플릿입니다.

---
## 🎯 학습 목표
- DP의 기초 패턴(작은 문제의 해를 이용해 큰 문제 해결하기)을 이해한다.
- Climbing Stairs 문제에서 점화식을 스스로 도출한다.
- 반복 DP(O(n))로 효율적으로 해결한다.
- 에지 케이스(n=1,2)를 정확히 다룬다.

---
## 📌 문제 설명
당신은 계단을 오르고 있습니다. 꼭대기에 도달하려면 **n개의 계단**을 올라야 합니다. 매번 한 번에 **1계단 또는 2계단**을 오를 수 있습니다.

**꼭대기까지 올라갈 수 있는 서로 다른 방법의 수를 구하세요.**

### 예시
- n = 2 → 2가지 방법 (1+1, 2)
- n = 3 → 3가지 방법 (1+1+1, 1+2, 2+1)

---
## 🛠️ Prerequisites
본 미션은 추가적 라이브러리 명시 없이 설계 가능합니다.

---
## Step 1. 문제 이해 및 테스트 케이스 분석
아래 칸에 직접 정리해보세요.


### ✏️ 테스트 케이스 분석 (학생 작성)
- n=1 일 때 경우의 수:1; 1가지
- n=2 일 때 경우의 수:1+1, 2; 2가지
- n=3 일 때 경우의 수:1+1+1,2+1,1+2; 3가지
- 직접 n=4, n=5 를 손으로 구해보면?
- n=4 일때, 1+1+1+1, 2+1+1, 1+2+1, 1+1+2, 2+2 ; 5가지
- n=5 일때, 1+1+1+1+1, 2+1+2, 1+2+2, 2+2+1, 1+1+1+2, 1+1+2+1, 1+2+1+1, 2+1+1+1 ; 8가지

---
## Step 2. DP 점화식 세우기
DP의 핵심은 **현재 칸으로 오기 위한 이전 상태들**을 찾는 것입니다.

힌트: `f(n) = f(n-1) + f(n-2)` 와 유사한 구조입니다.

아래에 점화식을 스스로 정의해 보세요.

### ✏️ 점화식 작성 (학생 작성)
- f(1) = 1
- f(2) = 2
- f(3) = f(2)+f(1) = 2 + 1 =3
- f(4) = f(3) + f(2)= 3 + 2 = 5
- f(n) = f(n-1)+f(n-2) (단 n>2)


---
## Step 3. 반복 DP 방식으로 코드 구현하기
`O(n)` 반복문으로 해결합니다.

아래 템플릿을 완성하세요.

class Solution:
    def climbStairs(self, n: int) -> int:
        """
        반복 DP를 사용해 f(n)을 계산하는 함수입니다.
        점화식 기반으로 bottom-up 방식으로 구현하세요.

        요구사항:
        - n=1,2 에 대한 에지 케이스 처리
        - O(n) 반복 DP
        """
        if n <= 2:  ##계단이 1개나 2개 일때는 바로 반환
            return n  ##엣지케이스 처리됨

        dp = [0]*(n + 1) 
        """인덱스 번호를 계단 칸수와 맞추기위해서 n+1,
        0을 n+1번 반복해서 리스트를 만들어놔
        ex>n=5,dp = [0,0,0,0,0,0]
        
        하필 인덱스에 0을 넣어 리스트를 만드는 것은, 
        비어있음, 아직 값이 채워지지 않음을 의미하는 초기값이다!!
        
        나중에, 코드를 실행하면서 dp[3] = 3 처럼 값을 채워넣을 텐데
        만약 값이 안바뀌고 여전히 0 이라면 아직 계산이 안됬거나 방법이
        없구나- 라고 알수있대"""

        dp[1] = 1
        dp[2] = 2  # 초기값처리, f(n) = f(n-1) + f(n-2), n >2 임

        for i in range(3, n + 1):  #n은 값이 주어질거고, 3부터 n+1까지 루프를 돌건데.
            dp[i] = dp[i-1] + dp[i-2]  #n이 3이면 range(3,4) 이고, range는 끝 숫자는 포함하지않으므로
                                        # i는 3 딱 하나만 실행된다

        return dp[n] #원하는 것은 n개의 계단을 오르는 방법의 총 가짓수 이므로
                    #for 반복문이 끝나고나면, 마지막 계산값인 dp[n]값을 출력해야
                    #우리가 원하는 값을 알 수 있다
        
        # TODO: 코드를 완성하세요.
        raise NotImplementedError


---
## Step 3-2. 코드 테스트
아래 테스트를 실행하여 올바른 값이 출력되는지 확인하세요.


def run_tests():
    sol = Solution()
    tests = [1,2,3,10,45]
    for n in tests:
        print(f"n={n}, ways={sol.climbStairs(n)}")

run_tests()


---
## Step 4. 시간복잡도 & 공간복잡도 분석
아래에 직접 정리해보세요.


### ✏️ 복잡도 분석 (학생 작성)
- 시간복잡도: O(N), 주어진n만큼 반복문을 돌려야 한다. N에 비례함
- 공간복잡도: O(n), 새로운 리스트를 만들어 n개만큼 저장해야 한다. 리스트의 크기가 N에 따라 결정된다


---
## Step 5. 코드 정리 & 결과 캡처
- 주석 포함해 코드 정리
- 테스트 결과를 실행해 스크린샷 촬영 (제출 시 포함)


###**콘텐츠 라이선스**
<font color='red'><b>**(주)업스테이지가 제공하는 모든 교육 콘텐츠의 지식재산권은
운영 주체인 (주)업스테이지 또는 해당 저작물의 적법한 관리자에게 귀속되어 있습니다.**</b></font>

콘텐츠 일부 또는 전부를 **복사, 복제, 판매, 재판매 공개, 공유** 등을 할 수 없습니다. 유출될 경우 지식재산권 침해에 대한 책임을 부담할 수 있습니다.

유출에 해당하여 금지되는 행위의 예시는 다음과 같습니다.
* 콘텐츠를 재가공하여 온/오프라인으로 공개하는 행위
* 콘텐츠의 일부 또는 전부를 이용하여 인쇄물을 만드는 행위
* 콘텐츠의 전부 또는 일부를 녹취 또는 녹화하거나 녹취록을 작성하는 행위
* 콘텐츠의 전부 또는 일부를 스크린 캡쳐하거나 카메라로 촬영하는 행위
* 지인을 포함한 제3자에게 콘텐츠의 일부 또는 전부를 공유하는 행위
* 다른 정보와 결합하여 Upstage Education의 콘텐츠임을 알아볼 수 있는 저작물을 작성, 공개하는 행위
* 제공된 데이터의 일부 혹은 전부를 Upstage Education 프로젝트/실습 수행 이외의 목적으로 사용하는 행위