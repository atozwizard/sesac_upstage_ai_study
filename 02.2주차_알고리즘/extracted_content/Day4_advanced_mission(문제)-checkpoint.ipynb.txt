# Day 4. 힙과 이진 탐색으로 문제 해결하기 – 심화 미션 (Rotated Sorted Array)

이 노트북은 **회전된 정렬 배열(rotated sorted array)** 에서 이진 탐색을 변형하여
원소를 찾는 문제를 다루는 심화 미션용입니다.

문제는 LeetCode **Search in Rotated Sorted Array** 를 기반으로 합니다.

## 🎯 학습 목표
- 회전된 정렬 배열의 구조를 이해한다.
- "항상 한 쪽 구간은 정렬되어 있다"는 성질을 이용해
  **변형된 이진 탐색 O(log n)** 알고리즘을 설계한다.
- 선형 탐색(`O(n)`)이 아닌, 진짜 로그 시간 탐색을 구현하는 연습을 한다.

---
## 문제: Search in Rotated Sorted Array

> **서로 다른(distinct) 정수** 로 구성된 오름차순 정렬 배열 `nums` 가 있습니다.
> 이 배열은 어떤 알 수 없는 인덱스 `k` 에서 **왼쪽으로 회전(left rotated)** 되었을 수 있습니다.

예를 들어,
- 원래 배열: `[0,1,2,4,5,6,7]`
- 인덱스 3만큼 회전 → `[4,5,6,7,0,1,2]`

이제 회전되었을 수도 있는 배열 `nums` 와 정수 `target` 이 주어졌을 때,
- `target` 이 배열 안에 존재하면 그 **인덱스** 를,
- 존재하지 않으면 `-1` 을 반환하세요.

### 예시
1. `nums = [4,5,6,7,0,1,2], target = 0` → `4`
2. `nums = [4,5,6,7,0,1,2], target = 3` → `-1`
3. `nums = [1], target = 0` → `-1`

### 제한 조건 (요약)
- `1 <= nums.length <= 5000`
- `-10^4 <= nums[i], target <= 10^4`
- `nums` 의 모든 값은 **서로 다르며**, 원래는 오름차순 정렬 상태였다가 회전되었을 수 있습니다.
- 알고리즘은 반드시 **O(log n)** 이어야 합니다.

---

## 🛠️ Prerequisites
본 미션은 파이썬 표준 라이브러리를 활용하며, 효율적인 알고리즘 구현을 위해 아래 모듈들을 사용합니다.
* **`from typing import List, Optional`**: 데이터 구조의 타입을 명확히 정의하기 위해 사용합니다.

## Step 1. 문제 이해 & 단순 접근과의 비교

먼저 이 문제를 **그냥 선형 탐색으로 풀면** 어떻게 되는지, 그리고 왜 안 되는지 생각해 봅시다.

### ✏️ 정리 (학생 작성)

- 단순 선형 탐색(linear search)로 풀면 시간복잡도는 얼마인가? 여기서 왜 요구 조건에 안 맞는가?
  - 전부 하나씩 다 봐야한다. O(N). 요구한 O(logN)에 맞지 않는다."logN 이려면 반드시 범위의 절반을 날려야 한다"
  - 
  - 
- 회전되기 전의 배열 구조는 어떤 모습이며, 회전 후에는 어떤 특징을 가지는가?
  -회전되기 전에 오름차순, 회전 후 모든 요소의 인덱스가 (-(len(nums)-k))
- 배열에 끊긴 지점이 생기고, 그 지점을 기준으로 양쪽으로 각각의 오름차순이 생김
  
- 이 문제에서 이진 탐색을 그대로 적용할 수 없는 이유와,
  "한 쪽 구간은 항상 정렬되어 있다"는 관찰이 왜 중요한지:
  - 회전했을 수도 있고, 아닐 수도 있기 때문에 확정해야 하는 이진 탐색은 불가.
  - 회전여부가 확정되면 쓸 수 있지 않나?
  - 항상 정렬되어 있는 한쪽 구간은 이진탐색을 쓸수 있다?!


---
## Step 2. 핵심 아이디어: 항상 한 쪽 구간은 정렬되어 있다

이 문제의 핵심은 다음 한 줄로 요약됩니다.

> `mid` 를 기준으로 왼쪽 구간 또는 오른쪽 구간 중 **한 쪽은 반드시 정렬되어 있다.**

### 알고리즘 개요
1. 항상 이진 탐색처럼 `left`, `right`, `mid` 를 유지합니다.
2. `nums[left] <= nums[mid]` 이면, **왼쪽 구간이 정렬** 되어 있는 것입니다.
   - 이 경우, `target` 이 왼쪽 정렬 구간 안에 있는지 범위를 비교해서
     - 왼쪽으로 탐색 범위를 줄일지,
     - 오른쪽을 볼지 결정합니다.
3. 그렇지 않으면, **오른쪽 구간이 정렬** 되어 있는 경우입니다.
   - 이때도 마찬가지로, `target` 이 오른쪽 정렬 구간 안에 속하는지 보고
     어느 쪽을 버릴지 결정합니다.

아래에 본인이 이해한 분기 로직을 자연어로 한 번 더 정리해 보세요.

### ✏️ 정렬 구간 판별 & 분기 로직 요약 (학생 작성)

- `nums[left] <= nums[mid]` 인 경우 (왼쪽 구간 정렬):
  - 이때 `target` 이 왼쪽 구간에 속하는 조건은?
    -if nums[left]<= target <= mid
  - 속하면 어디를 남기고, 어디를 버리는가?
    -왼쪽을 남기고, 오른쪽 버림
     right = mid -1, else left = mid + 1
- 반대로 오른쪽 구간이 정렬된 경우:
  - 이때 `target` 이 오른쪽 구간에 속하는 조건은?
    -if mid =< target =< nums[right]
  - 속하면 어디를 남기고, 어디를 버리는가?
    -왼쪽 버리고 , 오른쪽 남김
    left = mid +1, else right = mid -1


---
## Step 3. 변형된 이진 탐색 구현하기

이제 위에서 정리한 아이디어를 코드로 옮겨봅시다.

### 요구 사항
- 함수 시그니처:
  ```python
  class Solution:
      def search(self, nums: List[int], target: int) -> int:
  ```
- `target` 이 존재하면 **인덱스** 를, 없으면 `-1` 을 반환합니다.
- 시간복잡도는 반드시 `O(log n)` 이어야 합니다.
- 선형 탐색(`for` 로 전체를 도는 방식)이나 슬라이싱 기반 탐색은 사용하지 않습니다.

아래 템플릿을 완성해 보세요.

from typing import List

#데일리미션의 퀵셀렉트와 비슷한데???


class Solution:
    def search(self, nums: List[int], target: int) -> int:
        """회전된 정렬 배열에서 target의 인덱스를 찾습니다.

        아이디어:
            - 매 반복마다 mid를 기준으로 왼쪽/오른쪽 중 어느 쪽이 정렬 구간인지 판별합니다.
            - target이 정렬된 구간 안에 속하는지에 따라 탐색 범위를 절반으로 줄입니다.

        시간복잡도:
            - 매 단계마다 탐색 범위를 절반으로 줄이므로 O(log n) 입니다.
        """
        left, right = 0, len(nums) - 1
        
        while left <= right:
                mid = (left + right) // 2
                if nums[mid] == target:
                    return mid
                elif nums[left] <= nums[mid]:
                    if nums[left]<= target < nums[mid]:
                        right = mid - 1
                    else: left = mid + 1
                                            
                else: # nums[right] >= nums[mid]
                    if nums[mid] < target <= nums[right]:
                        left = mid + 1
                    else: right = mid - 1
        return -1
        # TODO: while 루프 안에서 mid를 계산하고,
        #       정렬된 구간을 판별한 뒤, target의 위치에 따라
        #       left/right 를 조정하는 로직을 작성해 보세요.
        # 힌트:
        #   - if nums[mid] == target: 바로 mid 반환
        #   - elif 왼쪽 구간이 정렬되어 있다면:
        #        target이 왼쪽 구간에 속하는지 비교 후, left/right 이동
        #   - else: 오른쪽 구간이 정렬되어 있는 경우
        #        target이 오른쪽 구간에 속하는지 비교 후, left/right 이동

        raise NotImplementedError


### ✅ 테스트 코드
아래 셀을 실행해 예시 입력 및 몇 가지 추가 케이스에서 결과를 확인해 보세요.
테스트 케이스를 스스로 더 추가해 보면 좋습니다.

def run_tests():
    sol = Solution()
    tests = [
        ([4,5,6,7,0,1,2], 0, 4),
        ([4,5,6,7,0,1,2], 3, -1),
        ([1], 0, -1),
        ([1], 1, 0),
        ([5,1,3], 3, 2),
        ([5,1,3], 5, 0),
        ([1,2,3,4,5,6,7,8,9],5,4)
    ]

    for nums, target, expected in tests:
        result = sol.search(nums, target)
        print(f"nums={nums}, target={target} → result={result}, expected={expected}")

run_tests()


---
## Step 4. 정리 및 자기 점검

### ✏️ 정리 (학생 작성)

- 이 문제에서 **정렬 + 탐색** 사고가 어떻게 사용되었는지 한 문단으로 요약해 보세요.
  -피벗한 mid를 기준으로 좌우의 정렬되어있을 것을 가정하고, 타겟을 탐색하며 범위를 좁혀가며 찾는다.
- 내가 작성한 코드에서 가장 헷갈렸던 조건(또는 버그가 많이 났던 부분)은?
  -정렬되어 있다면을 가정하여 타겟의 값을 비교하며 시작과 끝점을 이동하는 부분이 헷갈렸음
- 회전이 전혀 없는 경우(그냥 정렬 배열)에도 코드가 잘 동작하는지?
  -ㅇㅇ
- 동일한 패턴을 적용할 수 있을 것 같은 다른 문제 유형(예: 최소값 찾기, 중복 허용 버전 등):
  -회전된 정렬배열에서 최소값 찾기
  -산모양배열에서 최대값찾기

---
## ✅ 제출 전 체크리스트
- [ ] 선형 탐색이 아닌, 변형된 이진 탐색으로 구현했다.
- [ ] 회전된 배열의 구조 및 "한 쪽 구간은 정렬" 조건을 코드로 잘 옮겼다.
- [ ] target이 존재할 때는 인덱스, 없을 때는 -1을 반환한다.
- [ ] 예시 및 추가 테스트 케이스에서 기대한 결과가 나온다.
- [ ] 전체 알고리즘의 시간복잡도가 `O(log n)` 임을 설명할 수 있다.

수고 많았습니다! Day 4 심화 미션까지 완료했다면, 힙과 이진 탐색을 활용한
대표적인 패턴들을 한 번씩 모두 경험한 것입니다 🎯


###**콘텐츠 라이선스**
<font color='red'><b>**(주)업스테이지가 제공하는 모든 교육 콘텐츠의 지식재산권은
운영 주체인 (주)업스테이지 또는 해당 저작물의 적법한 관리자에게 귀속되어 있습니다.**</b></font>

콘텐츠 일부 또는 전부를 **복사, 복제, 판매, 재판매 공개, 공유** 등을 할 수 없습니다. 유출될 경우 지식재산권 침해에 대한 책임을 부담할 수 있습니다.

유출에 해당하여 금지되는 행위의 예시는 다음과 같습니다.
* 콘텐츠를 재가공하여 온/오프라인으로 공개하는 행위
* 콘텐츠의 일부 또는 전부를 이용하여 인쇄물을 만드는 행위
* 콘텐츠의 전부 또는 일부를 녹취 또는 녹화하거나 녹취록을 작성하는 행위
* 콘텐츠의 전부 또는 일부를 스크린 캡쳐하거나 카메라로 촬영하는 행위
* 지인을 포함한 제3자에게 콘텐츠의 일부 또는 전부를 공유하는 행위
* 다른 정보와 결합하여 Upstage Education의 콘텐츠임을 알아볼 수 있는 저작물을 작성, 공개하는 행위
* 제공된 데이터의 일부 혹은 전부를 Upstage Education 프로젝트/실습 수행 이외의 목적으로 사용하는 행위