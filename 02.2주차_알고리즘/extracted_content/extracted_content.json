{
  "pdfs": {
    "강의마무리_코랩 세션_Wrap Up 리포트.pdf": {
      "filename": "강의마무리_코랩 세션_Wrap Up 리포트.pdf",
      "char_count": 15087,
      "preview": " \n \n \n[\n자료구조와\n \n알고리즘\n]\n \n코랩세션\n \nWrap\n \nUp\n \n리포트\n \n작성팀:\n \n6조\n \n이영기\n \nWrap\n \nUp\n \n리포트\n \n작성\n \n내용\n \n1)\n \n논의\n \n주제\n \na)\n \n보라색으로\n \n작성된\n \n주제는\n \n예시\n \n주제로,\n \n팀\n \n내\n \n논의하고\n \n싶은\n \n주제가\n \n있다면\n \n해당\n \n주제로\n \n논의해주세요!\n \n2)\n \n팀원별\n \n핵심\n \n아이디어\n \n3)\n \n논의\n \n과정\n \n4)\n \n최종\n \n논의\n \n결과\n \n및\n \n회고\n \n \n공통\n \n예시\n \n주제\n \n(Day\n \n01\n \n-\n \nDay\n \n05)\n \nStep\n \n01.\n \nPseudo\n \ncode:\n \n내\n \n풀이를\n \n10~20줄\n \n내외로\n \n요약(입력\n \n출력,\n \n핵심\n \n로직,\n \n예외\n \n포함)\n \nStep\n \n02.\n \n시간\n \n공간\n \n복잡도:\n \n최선\n \n평균\n \n최악\n \n중\n \n무엇을\n \n기준으로\n \n말하는지\n \n명시\n \nStep\n \n03.\n \n효율성\n \n주장:"
    },
    "00.강의자료/Lecture 10.pdf": {
      "filename": "Lecture 10.pdf",
      "char_count": 1247,
      "preview": "Lecture 10:\nProblem Solving & Coding\n김수경\n이화여자대학교 인공지능융합전공 소속© 2025 Upstage Co., Ltd.\n1\n2저작권안내\n(주)업스테이지가 제공하는 모든교육콘텐츠의 지식재산권은\n운영주체인 (주)업스테이지 또는해당저작물의 적법한관리자에게 귀속되어 있습니다 .\n콘텐츠일부또는전부를복사 , 복제 , 판매 , 재판매공개 , 공유등을할수없습니다 . \n유출될경우지식재산권 침해에대한책임을부담할수있습니다 . \n유출에해당하여 금지되는 행위의예시는다음과같습니다 . \n● 콘텐츠를 재가공하여 온/오프라인으로 공개하는 행위\n● 콘텐츠의 일부 또는 전부를 이용하여 인쇄물을 만드는 행위\n● 콘텐츠의 전부 또는 일부를 녹취 또는 녹화하거나 녹취록을 작성하는 행위\n● 콘텐츠의 전부 또는 일부를 스크린 캡쳐하거나 카메라로 촬영하는 행위\n● 지인을 포함한 제3자에게 콘텐츠의 일부 또는 전부를 공유하는 행위\n● 다른 정보와 결합하여 Upstage Education 의콘텐츠임"
    },
    "00.강의자료/Lecture 2.pdf": {
      "filename": "Lecture 2.pdf",
      "char_count": 11988,
      "preview": "Lecture 2:\nArrays & Linked Lists\n김수경\n이화여자대학교 인공지능융합전공 소속© 2025 Upstage Co., Ltd.\n1\n2저작권안내\n(주)업스테이지가 제공하는 모든교육콘텐츠의 지식재산권은\n운영주체인 (주)업스테이지 또는해당저작물의 적법한관리자에게 귀속되어 있습니다 .\n콘텐츠일부또는전부를복사 , 복제 , 판매 , 재판매공개 , 공유등을할수없습니다 . \n유출될경우지식재산권 침해에대한책임을부담할수있습니다 . \n유출에해당하여 금지되는 행위의예시는다음과같습니다 . \n● 콘텐츠를 재가공하여 온/오프라인으로 공개하는 행위\n● 콘텐츠의 일부 또는 전부를 이용하여 인쇄물을 만드는 행위\n● 콘텐츠의 전부 또는 일부를 녹취 또는 녹화하거나 녹취록을 작성하는 행위\n● 콘텐츠의 전부 또는 일부를 스크린 캡쳐하거나 카메라로 촬영하는 행위\n● 지인을 포함한 제3자에게 콘텐츠의 일부 또는 전부를 공유하는 행위\n● 다른 정보와 결합하여 Upstage Education 의콘텐츠임을 알아"
    },
    "00.강의자료/Lecture 3.pdf": {
      "filename": "Lecture 3.pdf",
      "char_count": 10674,
      "preview": "Lecture 3:\nStacks & Queues\n김수경\n이화여자대학교 인공지능융합전공 소속© 2025 Upstage Co., Ltd.\n1\n2저작권안내\n(주)업스테이지가 제공하는 모든교육콘텐츠의 지식재산권은\n운영주체인 (주)업스테이지 또는해당저작물의 적법한관리자에게 귀속되어 있습니다 .\n콘텐츠일부또는전부를복사 , 복제 , 판매 , 재판매공개 , 공유등을할수없습니다 . \n유출될경우지식재산권 침해에대한책임을부담할수있습니다 . \n유출에해당하여 금지되는 행위의예시는다음과같습니다 . \n● 콘텐츠를 재가공하여 온/오프라인으로 공개하는 행위\n● 콘텐츠의 일부 또는 전부를 이용하여 인쇄물을 만드는 행위\n● 콘텐츠의 전부 또는 일부를 녹취 또는 녹화하거나 녹취록을 작성하는 행위\n● 콘텐츠의 전부 또는 일부를 스크린 캡쳐하거나 카메라로 촬영하는 행위\n● 지인을 포함한 제3자에게 콘텐츠의 일부 또는 전부를 공유하는 행위\n● 다른 정보와 결합하여 Upstage Education 의콘텐츠임을 알아볼 수있는 "
    },
    "00.강의자료/Lecture 4.pdf": {
      "filename": "Lecture 4.pdf",
      "char_count": 11501,
      "preview": "Lecture 4:\nHash Tables\n김수경\n이화여자대학교  인공지능융합전공  소속© 2025 Upstage Co., Ltd.\n1\n2저작권  안내\n(주)업스테이지가  제공하는  모든  교육  콘텐츠의  지식재산권은\n운영  주체인  (주)업스테이지  또는  해당  저작물의  적법한  관리자에게  귀속되어  있습니다 .\n콘텐츠  일부  또는  전부를  복사 , 복제 , 판매 , 재판매  공개 , 공유  등을  할 수 없습니다 . \n유출될  경우  지식재산권  침해에  대한  책임을  부담할  수 있습니다 . \n유출에  해당하여  금지되는  행위의  예시는  다음과  같습니다 . \n● 콘텐츠를  재가공하여  온/오프라인으로  공개하는  행위\n● 콘텐츠의  일부  또는  전부를  이용하여  인쇄물을  만드는  행위\n● 콘텐츠의  전부  또는  일부를  녹취  또는  녹화하거나  녹취록을  작성하는  행위\n● 콘텐츠의  전부  또는  일부를  스크린  캡쳐하거나  카메라로  촬영하는  행"
    },
    "00.강의자료/Lecture 5.pdf": {
      "filename": "Lecture 5.pdf",
      "char_count": 14670,
      "preview": "Lecture 5:\nTree\n김수경\n이화여자대학교  인공지능융합전공  소속© 2025 Upstage Co., Ltd.\n1\n2저작권  안내\n(주)업스테이지가  제공하는  모든  교육  콘텐츠의  지식재산권은\n운영  주체인  (주)업스테이지  또는  해당  저작물의  적법한  관리자에게  귀속되어  있습니다 .\n콘텐츠  일부  또는  전부를  복사 , 복제 , 판매 , 재판매  공개 , 공유  등을  할 수 없습니다 . \n유출될  경우  지식재산권  침해에  대한  책임을  부담할  수 있습니다 . \n유출에  해당하여  금지되는  행위의  예시는  다음과  같습니다 . \n● 콘텐츠를  재가공하여  온/오프라인으로  공개하는  행위\n● 콘텐츠의  일부  또는  전부를  이용하여  인쇄물을  만드는  행위\n● 콘텐츠의  전부  또는  일부를  녹취  또는  녹화하거나  녹취록을  작성하는  행위\n● 콘텐츠의  전부  또는  일부를  스크린  캡쳐하거나  카메라로  촬영하는  행위\n● 지인을"
    },
    "00.강의자료/Lecture 6.pdf": {
      "filename": "Lecture 6.pdf",
      "char_count": 14084,
      "preview": "Lecture 6:\nGraph & Search (BFS,DFS)\n김수경\n이화여자대학교 인공지능융합전공 소속© 2025 Upstage Co., Ltd.\n1\n2저작권 안내\n(주)업스테이지가 제공하는 모든 교육 콘텐츠의 지식재산권은\n운영 주체인 (주)업스테이지 또는 해당 저작물의 적법한 관리자에게 귀속되어 있습니다 .\n콘텐츠 일부 또는 전부를 복사 , 복제 , 판매 , 재판매 공개 , 공유 등을 할수없습니다 . \n유출될 경우 지식재산권 침해에 대한 책임을 부담할 수있습니다 . \n유출에 해당하여 금지되는 행위의 예시는 다음과 같습니다 . \n● 콘텐츠를 재가공하여 온/오프라인으로 공개하는 행위\n● 콘텐츠의 일부 또는 전부를 이용하여 인쇄물을 만드는 행위\n● 콘텐츠의 전부 또는 일부를 녹취 또는 녹화하거나 녹취록을 작성하는 행위\n● 콘텐츠의 전부 또는 일부를 스크린 캡쳐하거나 카메라로 촬영하는 행위\n● 지인을 포함한 제3자에게 콘텐츠의 일부 또는 전부를 공유하는 행위\n● 다른 정보와 결합하여 "
    },
    "00.강의자료/Lecture 7.pdf": {
      "filename": "Lecture 7.pdf",
      "char_count": 8245,
      "preview": "Lecture 7:\nPriority Queue & Heap\n김수경\n이화여자대학교 인공지능융합전공 소속© 2025 Upstage Co., Ltd.\n1\n2저작권안내\n(주)업스테이지가 제공하는 모든교육콘텐츠의 지식재산권은\n운영주체인 (주)업스테이지 또는해당저작물의 적법한관리자에게 귀속되어 있습니다 .\n콘텐츠일부또는전부를복사 , 복제 , 판매 , 재판매공개 , 공유등을할수없습니다 . \n유출될경우지식재산권 침해에대한책임을부담할수있습니다 . \n유출에해당하여 금지되는 행위의예시는다음과같습니다 . \n● 콘텐츠를 재가공하여 온/오프라인으로 공개하는 행위\n● 콘텐츠의 일부 또는 전부를 이용하여 인쇄물을 만드는 행위\n● 콘텐츠의 전부 또는 일부를 녹취 또는 녹화하거나 녹취록을 작성하는 행위\n● 콘텐츠의 전부 또는 일부를 스크린 캡쳐하거나 카메라로 촬영하는 행위\n● 지인을 포함한 제3자에게 콘텐츠의 일부 또는 전부를 공유하는 행위\n● 다른 정보와 결합하여 Upstage Education 의콘텐츠임을 알아"
    },
    "00.강의자료/Lecture 8.pdf": {
      "filename": "Lecture 8.pdf",
      "char_count": 7377,
      "preview": "Lecture 8:\nRecursion & Searching\n김수경\n이화여자대학교 인공지능융합전공 소속© 2025 Upstage Co., Ltd.\n1\n2저작권안내\n(주)업스테이지가 제공하는 모든교육콘텐츠의 지식재산권은\n운영주체인 (주)업스테이지 또는해당저작물의 적법한관리자에게 귀속되어 있습니다 .\n콘텐츠일부또는전부를복사 , 복제 , 판매 , 재판매공개 , 공유등을할수없습니다 . \n유출될경우지식재산권 침해에대한책임을부담할수있습니다 . \n유출에해당하여 금지되는 행위의예시는다음과같습니다 . \n● 콘텐츠를 재가공하여 온/오프라인으로 공개하는 행위\n● 콘텐츠의 일부 또는 전부를 이용하여 인쇄물을 만드는 행위\n● 콘텐츠의 전부 또는 일부를 녹취 또는 녹화하거나 녹취록을 작성하는 행위\n● 콘텐츠의 전부 또는 일부를 스크린 캡쳐하거나 카메라로 촬영하는 행위\n● 지인을 포함한 제3자에게 콘텐츠의 일부 또는 전부를 공유하는 행위\n● 다른 정보와 결합하여 Upstage Education 의콘텐츠임을 알아"
    },
    "00.강의자료/Lecture 9.pdf": {
      "filename": "Lecture 9.pdf",
      "char_count": 16043,
      "preview": "Lecture 9:\nSorting Algorithms\n김수경\n이화여자대학교 인공지능융합전공 소속© 2025 Upstage Co., Ltd.\n1\n2저작권안내\n(주)업스테이지가 제공하는 모든교육콘텐츠의 지식재산권은\n운영주체인 (주)업스테이지 또는해당저작물의 적법한관리자에게 귀속되어 있습니다 .\n콘텐츠일부또는전부를복사 , 복제 , 판매 , 재판매공개 , 공유등을할수없습니다 . \n유출될경우지식재산권 침해에대한책임을부담할수있습니다 . \n유출에해당하여 금지되는 행위의예시는다음과같습니다 . \n● 콘텐츠를 재가공하여 온/오프라인으로 공개하는 행위\n● 콘텐츠의 일부 또는 전부를 이용하여 인쇄물을 만드는 행위\n● 콘텐츠의 전부 또는 일부를 녹취 또는 녹화하거나 녹취록을 작성하는 행위\n● 콘텐츠의 전부 또는 일부를 스크린 캡쳐하거나 카메라로 촬영하는 행위\n● 지인을 포함한 제3자에게 콘텐츠의 일부 또는 전부를 공유하는 행위\n● 다른 정보와 결합하여 Upstage Education 의콘텐츠임을 알아볼 수"
    },
    "00.강의자료/lecture01.pdf": {
      "filename": "lecture01.pdf",
      "char_count": 7095,
      "preview": "Lecture 1: \nBasic of Algorithm & \nComputational Complexity \n김수경 \n이화여자대학교 인공지능융합전공 소속 © 2025 Upstage Co., Ltd. \n2 저작권 안내 \n \n(주)업스테이지가 제공하는 모든 교육 콘텐츠의 지식재산권은 \n운영 주체인 (주)업스테이지 또는 해당 저작물의 적법한 관리자에게 귀속되어 있습니다. \n콘텐츠 일부 또는 전부를 복사, 복제, 판매, 재판매 공개, 공유 등을 할 수 없습니다. \n유출될 경우 지식재산권 침해에 대한 책임을 부담할 수 있습니다. \n유출에 해당하여 금지되는 행위의 예시는 다음과 같습니다. \n● 콘텐츠를 재가공하여 온/오프라인으로 공개하는 행위 \n● 콘텐츠의 일부 또는 전부를 이용하여 인쇄물을 만드는 행위 \n● 콘텐츠의 전부 또는 일부를 녹취 또는 녹화하거나 녹취록을 작성하는 행위 \n● 콘텐츠의 전부 또는 일부를 스크린 캡쳐하거나 카메라로 촬영하는 행위 \n● 지인을 포함한 제3자에게 콘텐츠의 일부"
    }
  },
  "notebooks": {
    ".ipynb_checkpoints/ApplicationQuestion-checkpoint.ipynb": {
      "filename": "ApplicationQuestion-checkpoint.ipynb",
      "char_count": 5047,
      "preview": "02\n    1.middle of a given linked list\n    #중간값 찾기\n    #투 포인터, slow pointer 한번에 한칸씩 이동, fast pointer 한번에 두칸씩 이동\n    #fast pointer가 리스트의 끝(none)에 도달 했을 때, slow pointer는 정확히 리스트의 중간에 위치.     \n\n        class Node():\n            def __init__(self, val = 0, next = None): \"\"\"val은 value데이터=0 인것은 노드를 생성할 때 실수로 데이터를 넣지 않더라도,\n                                                        프로그램이 멈추지 않고 숫자 0을 기본 데이터로 가지게 한다. 주로 숫자데이터를 다룰 것이라는 점도 암시.\n                                                        next=None은"
    },
    ".ipynb_checkpoints/Day1_advanced_mission(문제)-checkpoint.ipynb": {
      "filename": "Day1_advanced_mission(문제)-checkpoint.ipynb",
      "char_count": 3043,
      "preview": "# Day 1. 배열과 알고리즘으로 문제 해결하기 – 심화 미션\n\n이 노트북은 **in-place 배열 조작**과 **two-pointer 전략**을 연습하기 위한 심화 과제용입니다.\n\n## 🎯 학습 목표\n- 추가 메모리를 거의 사용하지 않는 **in-place 알고리즘** 개념을 이해한다.\n- **two-pointer 패턴(write/read 포인터 등)** 을 실제 문제에 적용해본다.\n- 간단한 최적화를 통해 전체 연산 횟수를 줄이는 아이디어를 연습한다.\n\n---\n## 오늘의 심화 문제: LeetCode #283 – Move Zeroes\n\n정수 배열 `nums`가 주어질 때,\n배열 안의 모든 `0`을 **배열의 뒤쪽으로 이동**시키되,\n`0이 아닌 원소들의 상대적 순서는 유지`하도록 배열을 재배치하세요.\n\n이 작업은 **in-place**, 즉 **새로운 배열을 생성하지 않고** 수행해야 합니다.\n\n### 예시\n1. 입력: `nums = [0, 1, 0, 3, 12]` → 출력:"
    },
    ".ipynb_checkpoints/Day1_daily_mission(문제)-checkpoint.ipynb": {
      "filename": "Day1_daily_mission(문제)-checkpoint.ipynb",
      "char_count": 4120,
      "preview": "# Day 1. 배열과 알고리즘으로 문제 해결하기 – 데일리 미션\n\n이 노트북은 **배열과 기초 알고리즘 설계**를 연습하기 위한 데일리 미션용입니다.\n\n## 🎯 학습 목표\n- 배열의 인덱스 기반 접근 방식과 메모리 구조를 이해한다.\n- 브루트 포스(Brute Force)와 해시맵(Hash Map) 알고리즘의 **시간복잡도 차이**를 체험한다.\n- 같은 문제를 두 가지 방식으로 풀어보고, 어떤 상황에서 더 나은 방법을 선택해야 하는지 정리한다.\n\n---\n## 오늘의 문제: LeetCode #1 – Two Sum\n\n정수 배열 `nums`와 정수 `target`이 주어질 때,\n배열에서 **합이 `target`이 되는 서로 다른 두 수의 인덱스**를 반환하세요.\n\n### 조건\n- 각 입력에는 **정확히 하나의 해**만 존재합니다.\n- 같은 원소를 두 번 사용할 수 없습니다.\n- 반환 순서는 상관 없습니다.\n\n### 예시\n1. `nums = [2, 7, 11, 15]`, `target = "
    },
    ".ipynb_checkpoints/Day2_advanced_mission(문제)-checkpoint.ipynb": {
      "filename": "Day2_advanced_mission(문제)-checkpoint.ipynb",
      "char_count": 5764,
      "preview": "# Day 2. 스택으로 문제 해결하기 – 심화 미션 (Daily Temperatures)\n\n이 노트북은 **Monotonic Stack(단조 스택)** 패턴을 연습하기 위한 심화 과제용입니다.\nLeetCode **#739 Daily Temperatures** 문제를 풀며, 스택을 이용한 **인덱스 기반 문제 해결**을 경험합니다.\n\n## 🎯 학습 목표\n- 스택에 **값이 아닌 인덱스(index)** 를 저장하여 문제를 푸는 패턴을 익힌다.\n- **Monotonic Stack(단조 증가/단조 감소 스택)** 의 개념을 이해하고 구현한다.\n- 온도 배열에서 \"다음에 더 따뜻한 날\"까지의 거리를 효율적으로 계산한다.\n\n---\n## 문제: LeetCode #739 — Daily Temperatures\n\n정수 배열 `temperatures` 가 주어질 때, **각 날짜마다** 현재 온도보다 더 따뜻한 날이 오기까지\n몇 일을 기다려야 하는지 계산해서 배열로 반환하세요.\n\n더 따뜻한 날이 없다"
    },
    ".ipynb_checkpoints/Day2_daily_mission(문제)-checkpoint.ipynb": {
      "filename": "Day2_daily_mission(문제)-checkpoint.ipynb",
      "char_count": 6842,
      "preview": "# Day 2. 스택으로 문제 해결하기 – 데일리 미션 (Valid Parentheses)\n\n이 노트북은 **스택(Stack)** 을 활용해 LeetCode **#20 Valid Parentheses** 문제를 푸는 데일리 미션용입니다.\n\n## 🎯 학습 목표\n- 스택의 **LIFO(Last-In, First-Out)** 구조와 `push`/`pop` 연산을 이해한다.\n- 문자열 속 괄호 패턴을 **스택으로 검증하는 알고리즘**을 설계하고 구현한다.\n- 시간복잡도 `O(N)` 알고리즘을 직접 작성하고 분석한다.\n\n---\n## 문제: LeetCode #20 — Valid Parentheses\n\n문자열 `s` 가 주어졌을 때, 문자열이 **올바른 괄호 구성(valid parentheses)** 인지 판별하는 함수를 작성하세요.\n\n문자열 `s` 는 `'(', ')', '{', '}', '[', ']'` 문자로만 이루어져 있습니다.\n\n올바른 괄호의 조건은 다음과 같습니다.\n1. 열린 괄호는 "
    },
    ".ipynb_checkpoints/Untitled-checkpoint.ipynb": {
      "filename": "Untitled-checkpoint.ipynb",
      "char_count": 0,
      "preview": ""
    },
    "01.daily_mission/Day1_daily_mission(문제)_leetcode001.ipynb": {
      "filename": "Day1_daily_mission(문제)_leetcode001.ipynb",
      "char_count": 5814,
      "preview": "# Day 1. 배열과 알고리즘으로 문제 해결하기 – 데일리 미션\n\n이 노트북은 **배열과 기초 알고리즘 설계**를 연습하기 위한 데일리 미션용입니다.\n\n## 🎯 학습 목표\n- 배열의 인덱스 기반 접근 방식과 메모리 구조를 이해한다.\n- 브루트 포스(Brute Force)와 해시맵(Hash Map) 알고리즘의 **시간복잡도 차이**를 체험한다.\n- 같은 문제를 두 가지 방식으로 풀어보고, 어떤 상황에서 더 나은 방법을 선택해야 하는지 정리한다.\n\n---\n## 오늘의 문제: LeetCode #1 – Two Sum\n\n정수 배열 `nums`와 정수 `target`이 주어질 때,\n배열에서 **합이 `target`이 되는 서로 다른 두 수의 인덱스**를 반환하세요.\n\n### 조건\n- 각 입력에는 **정확히 하나의 해**만 존재합니다.\n- 같은 원소를 두 번 사용할 수 없습니다.\n- 반환 순서는 상관 없습니다.\n\n### 예시\n1. `nums = [2, 7, 11, 15]`, `target = "
    },
    "01.daily_mission/Day2_daily_mission(문제).ipynb": {
      "filename": "Day2_daily_mission(문제).ipynb",
      "char_count": 8033,
      "preview": "# Day 2. 스택으로 문제 해결하기 – 데일리 미션 (Valid Parentheses)\n\n이 노트북은 **스택(Stack)** 을 활용해 LeetCode **#20 Valid Parentheses** 문제를 푸는 데일리 미션용입니다.\n\n## 🎯 학습 목표\n- 스택의 **LIFO(Last-In, First-Out)** 구조와 `push`/`pop` 연산을 이해한다.\n- 문자열 속 괄호 패턴을 **스택으로 검증하는 알고리즘**을 설계하고 구현한다.\n- 시간복잡도 `O(N)` 알고리즘을 직접 작성하고 분석한다.\n\n---\n## 문제: LeetCode #20 — Valid Parentheses\n\n문자열 `s` 가 주어졌을 때, 문자열이 **올바른 괄호 구성(valid parentheses)** 인지 판별하는 함수를 작성하세요.\n\n문자열 `s` 는 `'(', ')', '{', '}', '[', ']'` 문자로만 이루어져 있습니다.\n\n올바른 괄호의 조건은 다음과 같습니다.\n1. 열린 괄호는 "
    },
    "01.daily_mission/Day3_daily_mission(문제)_leetcode104.ipynb": {
      "filename": "Day3_daily_mission(문제)_leetcode104.ipynb",
      "char_count": 8670,
      "preview": "# Day 3. 트리와 그래프로 탐색하기 – 데일리 미션\n\n이 노트북은 **이진 트리의 최대 깊이(Maximum Depth)** 를 구하는 문제를 통해\n재귀 DFS와 BFS(레벨 순회)를 모두 연습하는 데일리 미션용입니다.\n\n문제는 LeetCode **#104 – Maximum Depth of Binary Tree** 를 기반으로 합니다.\n\n## 🎯 학습 목표\n- 이진 트리의 **높이(최대 깊이) 정의**를 명확히 이해한다.\n- 재귀 DFS로 \"현재 노드 기준 서브트리의 높이\"를 계산하는 패턴을 익힌다.\n- `collections.deque` 를 이용한 **BFS 레벨 순회**로 깊이를 구해 본다.\n- DFS와 BFS의 차이를 **호출 스택 vs 큐**, 재귀 vs 반복 관점에서 비교한다.\n\n---\n## 문제: Maximum Depth of Binary Tree\n\n> 이진 트리의 루트 노드 `root` 가 주어졌을 때, 이 트리의 **최대 깊이(maximum depth)** 를 반환"
    },
    "01.daily_mission/Day4_daily_mission(문제)_leetcode215.ipynb": {
      "filename": "Day4_daily_mission(문제)_leetcode215.ipynb",
      "char_count": 9006,
      "preview": "# Day 4. 힙과 이진 탐색으로 문제 해결하기 – 데일리 미션 (Kth Largest)\n\n이 노트북은 **힙(Priority Queue)** 를 활용해 LeetCode **#215 – Kth Largest Element in an Array**\n문제를 푸는 데일리 미션용입니다.\n\n## 🎯 학습 목표\n- 전체 정렬을 하지 않고도 **k번째로 큰 원소**를 찾는 방법을 이해한다.\n- `heapq` 모듈을 활용하여 **min-heap 기반 top-k 패턴**을 구현한다.\n- 정렬(`O(n log n)`) vs 힙(`O(n log k)`) vs QuickSelect(평균 `O(n)`)의\n  시간복잡도 차이를 설명할 수 있다.\n\n---\n## 문제: Kth Largest Element in an Array\n\n> 정수 배열 `nums` 와 정수 `k` 가 주어질 때,\n> 배열을 내림차순 정렬했을 때의 **k번째로 큰 값(Kth largest)** 를 반환하세요.\n\n- \"서로 다른 값의 k번째"
    },
    "01.daily_mission/Day5_daily_mission(문제).ipynb": {
      "filename": "Day5_daily_mission(문제).ipynb",
      "char_count": 3419,
      "preview": "# Day 5. 동적 프로그래밍 기초 – 데일리 미션\n## LeetCode #70 — Climbing Stairs\n\n이 노트북은 Day 5 데일리 미션인 **Climbing Stairs (DP)** 문제를 풀이하기 위한 학생용 템플릿입니다.\n\n---\n## 🎯 학습 목표\n- DP의 기초 패턴(작은 문제의 해를 이용해 큰 문제 해결하기)을 이해한다.\n- Climbing Stairs 문제에서 점화식을 스스로 도출한다.\n- 반복 DP(O(n))로 효율적으로 해결한다.\n- 에지 케이스(n=1,2)를 정확히 다룬다.\n\n---\n## 📌 문제 설명\n당신은 계단을 오르고 있습니다. 꼭대기에 도달하려면 **n개의 계단**을 올라야 합니다. 매번 한 번에 **1계단 또는 2계단**을 오를 수 있습니다.\n\n**꼭대기까지 올라갈 수 있는 서로 다른 방법의 수를 구하세요.**\n\n### 예시\n- n = 2 → 2가지 방법 (1+1, 2)\n- n = 3 → 3가지 방법 (1+1+1, 1+2, 2+1)\n\n---\n"
    },
    "02.advanced_mission/Day1_advanced_mission(문제).ipynb": {
      "filename": "Day1_advanced_mission(문제).ipynb",
      "char_count": 6782,
      "preview": "# Day 1. 배열과 알고리즘으로 문제 해결하기 – 심화 미션\n\n이 노트북은 **in-place 배열 조작**과 **two-pointer 전략**을 연습하기 위한 심화 과제용입니다.\n\n## 🎯 학습 목표\n- 추가 메모리를 거의 사용하지 않는 **in-place 알고리즘** 개념을 이해한다.\n- **two-pointer 패턴(write/read 포인터 등)** 을 실제 문제에 적용해본다.\n- 간단한 최적화를 통해 전체 연산 횟수를 줄이는 아이디어를 연습한다.\n\n---\n## 오늘의 심화 문제: LeetCode #283 – Move Zeroes\n\n정수 배열 `nums`가 주어질 때,\n배열 안의 모든 `0`을 **배열의 뒤쪽으로 이동**시키되,\n`0이 아닌 원소들의 상대적 순서는 유지`하도록 배열을 재배치하세요.\n\n이 작업은 **in-place**, 즉 **새로운 배열을 생성하지 않고** 수행해야 합니다.\n\n### 예시\n1. 입력: `nums = [0, 1, 0, 3, 12]` → 출력:"
    },
    "02.advanced_mission/Day2_advanced_mission(문제).ipynb": {
      "filename": "Day2_advanced_mission(문제).ipynb",
      "char_count": 5764,
      "preview": "# Day 2. 스택으로 문제 해결하기 – 심화 미션 (Daily Temperatures)\n\n이 노트북은 **Monotonic Stack(단조 스택)** 패턴을 연습하기 위한 심화 과제용입니다.\nLeetCode **#739 Daily Temperatures** 문제를 풀며, 스택을 이용한 **인덱스 기반 문제 해결**을 경험합니다.\n\n## 🎯 학습 목표\n- 스택에 **값이 아닌 인덱스(index)** 를 저장하여 문제를 푸는 패턴을 익힌다.\n- **Monotonic Stack(단조 증가/단조 감소 스택)** 의 개념을 이해하고 구현한다.\n- 온도 배열에서 \"다음에 더 따뜻한 날\"까지의 거리를 효율적으로 계산한다.\n\n---\n## 문제: LeetCode #739 — Daily Temperatures\n\n정수 배열 `temperatures` 가 주어질 때, **각 날짜마다** 현재 온도보다 더 따뜻한 날이 오기까지\n몇 일을 기다려야 하는지 계산해서 배열로 반환하세요.\n\n더 따뜻한 날이 없다"
    },
    "02.advanced_mission/Day3_advanced_mission(문제)_leetcode200.ipynb": {
      "filename": "Day3_advanced_mission(문제)_leetcode200.ipynb",
      "char_count": 14390,
      "preview": "# Day 3. 트리와 그래프로 탐색하기 – 심화 미션\n\n이 노트북은 2차원 격자(지도)를 **그래프**로 보는 관점을 연습하고,\nDFS 또는 BFS를 사용해 **연결 요소 개수(섬의 개수)** 를 세는 심화 미션용입니다.\n\n문제는 LeetCode **#200 – Number of Islands** 를 기반으로 합니다.\n\n## 🎯 학습 목표\n- 2D grid 를 \"정점: 칸, 간선: 상하좌우 인접\"인 그래프로 모델링할 수 있다.\n- DFS 또는 BFS로 **연결된 영역(connected component)** 을 순회하는 패턴을 익힌다.\n- 방문 처리(visited 배열 또는 grid 값을 변경)의 중요성을 이해한다.\n- 다양한 테스트 케이스에서 섬의 개수를 정확히 세고, 대각선 연결은 같은 섬이 아님을 주의한다.\n\n---\n## 문제: Number of Islands\n\n> `m x n` 크기의 2D 이진 그리드 `grid` 가 주어질 때,\n> 섬(island)의 개수를 반환하세요.\n"
    },
    "02.advanced_mission/Day4_advanced_mission(문제).ipynb": {
      "filename": "Day4_advanced_mission(문제).ipynb",
      "char_count": 6223,
      "preview": "# Day 4. 힙과 이진 탐색으로 문제 해결하기 – 심화 미션 (Rotated Sorted Array)\n\n이 노트북은 **회전된 정렬 배열(rotated sorted array)** 에서 이진 탐색을 변형하여\n원소를 찾는 문제를 다루는 심화 미션용입니다.\n\n문제는 LeetCode **Search in Rotated Sorted Array** 를 기반으로 합니다.\n\n## 🎯 학습 목표\n- 회전된 정렬 배열의 구조를 이해한다.\n- \"항상 한 쪽 구간은 정렬되어 있다\"는 성질을 이용해\n  **변형된 이진 탐색 O(log n)** 알고리즘을 설계한다.\n- 선형 탐색(`O(n)`)이 아닌, 진짜 로그 시간 탐색을 구현하는 연습을 한다.\n\n---\n## 문제: Search in Rotated Sorted Array\n\n> **서로 다른(distinct) 정수** 로 구성된 오름차순 정렬 배열 `nums` 가 있습니다.\n> 이 배열은 어떤 알 수 없는 인덱스 `k` 에서 **왼쪽으로 회전(left"
    },
    "02.advanced_mission/Day5_advanced_mission(문제)_leetcode-056.ipynb": {
      "filename": "Day5_advanced_mission(문제)_leetcode-056.ipynb",
      "char_count": 5141,
      "preview": "# Day 5. 구간 병합 알고리즘 – 심화 미션\n## LeetCode #56 — Merge Intervals\n\n이 노트북은 Day 5 심화 과제인 **정렬 + 병합(sweep)** 패턴을 구현하기 위한 학생용 템플릿입니다.\n\n---\n## 🎯 학습 목표\n- 정렬된 구간(intervals)을 순차적으로 탐색하며 병합하는 알고리즘을 이해한다.\n- \"정렬 → 선형 스캔 → 조건 분기\" 패턴을 구현한다.\n- 병합 조건(`start <= last_end`)을 정확히 다룬다.\n- 시간복잡도 O(n log n) + O(n) 을 설명할 수 있다.\n\n---\n## 📌 문제 설명\n서로 겹치는 모든 구간(intervals)을 병합하여, 병합된 구간만 포함하는 배열을 반환하세요.\n\n### 예시\n입력: `[[1,3],[2,6],[8,10],[15,18]]`\n출력: `[[1,6],[8,10],[15,18]]`\n\n---\n## 🛠️ Prerequisites\n본 미션은 효율적인 데이터 처리를 위해 파이썬 내장 모듈"
    },
    "02.advanced_mission/.ipynb_checkpoints/Day4_advanced_mission(문제)-checkpoint.ipynb": {
      "filename": "Day4_advanced_mission(문제)-checkpoint.ipynb",
      "char_count": 6223,
      "preview": "# Day 4. 힙과 이진 탐색으로 문제 해결하기 – 심화 미션 (Rotated Sorted Array)\n\n이 노트북은 **회전된 정렬 배열(rotated sorted array)** 에서 이진 탐색을 변형하여\n원소를 찾는 문제를 다루는 심화 미션용입니다.\n\n문제는 LeetCode **Search in Rotated Sorted Array** 를 기반으로 합니다.\n\n## 🎯 학습 목표\n- 회전된 정렬 배열의 구조를 이해한다.\n- \"항상 한 쪽 구간은 정렬되어 있다\"는 성질을 이용해\n  **변형된 이진 탐색 O(log n)** 알고리즘을 설계한다.\n- 선형 탐색(`O(n)`)이 아닌, 진짜 로그 시간 탐색을 구현하는 연습을 한다.\n\n---\n## 문제: Search in Rotated Sorted Array\n\n> **서로 다른(distinct) 정수** 로 구성된 오름차순 정렬 배열 `nums` 가 있습니다.\n> 이 배열은 어떤 알 수 없는 인덱스 `k` 에서 **왼쪽으로 회전(left"
    },
    "02.advanced_mission/.ipynb_checkpoints/Day5_advanced_mission(문제)_leetcode-056-checkpoint.ipynb": {
      "filename": "Day5_advanced_mission(문제)_leetcode-056-checkpoint.ipynb",
      "char_count": 5141,
      "preview": "# Day 5. 구간 병합 알고리즘 – 심화 미션\n## LeetCode #56 — Merge Intervals\n\n이 노트북은 Day 5 심화 과제인 **정렬 + 병합(sweep)** 패턴을 구현하기 위한 학생용 템플릿입니다.\n\n---\n## 🎯 학습 목표\n- 정렬된 구간(intervals)을 순차적으로 탐색하며 병합하는 알고리즘을 이해한다.\n- \"정렬 → 선형 스캔 → 조건 분기\" 패턴을 구현한다.\n- 병합 조건(`start <= last_end`)을 정확히 다룬다.\n- 시간복잡도 O(n log n) + O(n) 을 설명할 수 있다.\n\n---\n## 📌 문제 설명\n서로 겹치는 모든 구간(intervals)을 병합하여, 병합된 구간만 포함하는 배열을 반환하세요.\n\n### 예시\n입력: `[[1,3],[2,6],[8,10],[15,18]]`\n출력: `[[1,6],[8,10],[15,18]]`\n\n---\n## 🛠️ Prerequisites\n본 미션은 효율적인 데이터 처리를 위해 파이썬 내장 모듈"
    },
    "01.daily_mission/.ipynb_checkpoints/Day4_daily_mission(문제)-checkpoint.ipynb": {
      "filename": "Day4_daily_mission(문제)-checkpoint.ipynb",
      "char_count": 9006,
      "preview": "# Day 4. 힙과 이진 탐색으로 문제 해결하기 – 데일리 미션 (Kth Largest)\n\n이 노트북은 **힙(Priority Queue)** 를 활용해 LeetCode **#215 – Kth Largest Element in an Array**\n문제를 푸는 데일리 미션용입니다.\n\n## 🎯 학습 목표\n- 전체 정렬을 하지 않고도 **k번째로 큰 원소**를 찾는 방법을 이해한다.\n- `heapq` 모듈을 활용하여 **min-heap 기반 top-k 패턴**을 구현한다.\n- 정렬(`O(n log n)`) vs 힙(`O(n log k)`) vs QuickSelect(평균 `O(n)`)의\n  시간복잡도 차이를 설명할 수 있다.\n\n---\n## 문제: Kth Largest Element in an Array\n\n> 정수 배열 `nums` 와 정수 `k` 가 주어질 때,\n> 배열을 내림차순 정렬했을 때의 **k번째로 큰 값(Kth largest)** 를 반환하세요.\n\n- \"서로 다른 값의 k번째"
    },
    "01.daily_mission/.ipynb_checkpoints/Day4_daily_mission(문제)_leetcode215-checkpoint.ipynb": {
      "filename": "Day4_daily_mission(문제)_leetcode215-checkpoint.ipynb",
      "char_count": 9006,
      "preview": "# Day 4. 힙과 이진 탐색으로 문제 해결하기 – 데일리 미션 (Kth Largest)\n\n이 노트북은 **힙(Priority Queue)** 를 활용해 LeetCode **#215 – Kth Largest Element in an Array**\n문제를 푸는 데일리 미션용입니다.\n\n## 🎯 학습 목표\n- 전체 정렬을 하지 않고도 **k번째로 큰 원소**를 찾는 방법을 이해한다.\n- `heapq` 모듈을 활용하여 **min-heap 기반 top-k 패턴**을 구현한다.\n- 정렬(`O(n log n)`) vs 힙(`O(n log k)`) vs QuickSelect(평균 `O(n)`)의\n  시간복잡도 차이를 설명할 수 있다.\n\n---\n## 문제: Kth Largest Element in an Array\n\n> 정수 배열 `nums` 와 정수 `k` 가 주어질 때,\n> 배열을 내림차순 정렬했을 때의 **k번째로 큰 값(Kth largest)** 를 반환하세요.\n\n- \"서로 다른 값의 k번째"
    },
    "01.daily_mission/.ipynb_checkpoints/Day5_daily_mission(문제)-checkpoint.ipynb": {
      "filename": "Day5_daily_mission(문제)-checkpoint.ipynb",
      "char_count": 3419,
      "preview": "# Day 5. 동적 프로그래밍 기초 – 데일리 미션\n## LeetCode #70 — Climbing Stairs\n\n이 노트북은 Day 5 데일리 미션인 **Climbing Stairs (DP)** 문제를 풀이하기 위한 학생용 템플릿입니다.\n\n---\n## 🎯 학습 목표\n- DP의 기초 패턴(작은 문제의 해를 이용해 큰 문제 해결하기)을 이해한다.\n- Climbing Stairs 문제에서 점화식을 스스로 도출한다.\n- 반복 DP(O(n))로 효율적으로 해결한다.\n- 에지 케이스(n=1,2)를 정확히 다룬다.\n\n---\n## 📌 문제 설명\n당신은 계단을 오르고 있습니다. 꼭대기에 도달하려면 **n개의 계단**을 올라야 합니다. 매번 한 번에 **1계단 또는 2계단**을 오를 수 있습니다.\n\n**꼭대기까지 올라갈 수 있는 서로 다른 방법의 수를 구하세요.**\n\n### 예시\n- n = 2 → 2가지 방법 (1+1, 2)\n- n = 3 → 3가지 방법 (1+1+1, 1+2, 2+1)\n\n---\n"
    }
  }
}